# A0139817U
###### /java/seedu/address/commons/collections/UniqueItemCollection.java
``` java
    /**
     * Duplicates an existing UniqueItemCollection
     */
    @SuppressWarnings("unchecked")
	public UniqueItemCollection<T> copyCollection()  {
    	UniqueItemCollection<T> copiedCollection = new UniqueItemCollection<T>();
    	for (T item : internalList) {
    		try {
	    		if (item instanceof Copiable) {
	    			Copiable<T> copiableItem = (Copiable<T>) item;
	    			copiedCollection.add(copiableItem.copy());
	    		} else {
	    			assert false : "The items in the list must implement the Copiable interface";
	    		}
    		} catch (DuplicateItemException die) {
    			assert false : "There should be no duplicate items in the UniqueItemCollection";
    		}
    	}
    	return copiedCollection;
    }

```
###### /java/seedu/address/commons/collections/UniqueItemCollection.java
``` java
    /**
     * Replaces an item to remove with an item to add from the list.
     * 
     * @throws ItemNotFoundException if the item to be removed cannot be found in the list.
     */
    public boolean replace(T toRemove, T toAdd) throws ItemNotFoundException {
    	assert toRemove != null && toAdd != null;
    	for (int i = 0; i < internalList.size(); i++) {
    		if (internalList.get(i) == toRemove) {
    			internalList.remove(i);
    			internalList.add(i, toAdd);
    			return true;
    		}
    	}
    	throw new ItemNotFoundException();
    }

```
###### /java/seedu/address/commons/events/model/NewTaskListEvent.java
``` java
public class NewTaskListEvent extends BaseEvent {

	public final UniqueItemCollection<Task> newTasks;
    public final FilteredList<Task> filteredTasks;

    public NewTaskListEvent(UniqueItemCollection<Task> newTasks, FilteredList<Task> filteredTasks){
        this.newTasks = newTasks;
        this.filteredTasks = filteredTasks;
    }

    @Override
    public String toString() {
        return "number of tasks " + newTasks.getInternalList().size();
    }
}
```
###### /java/seedu/address/commons/util/DateUtil.java
``` java
public class DateUtil {
	// Format for displaying dates
	public static final SimpleDateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy");
	
	/**
     * Checks if a string follows a valid date format.
     * 
     * The following examples are all valid and similar dates: 
     * "Oct 31". "31 Oct".
     * "31 Oct 2016". "Oct 31 2016".
     */
    public static boolean isValidDateFormat(String dateString) {
    	Date date = getDate(dateString);
    	// date has a value (not null) if dateString is a valid format
    	return (date != null);
    }
    
    /**
     * Checks if a string follows a valid format (using "to" or "-") to show start date and end date.
     * 
     * The following examples are all valid and similar illustrations: 
     * "Sep 31 - Oct 31". "31 Sep 2016 - 31 Oct 2016". 
     * "Sep 31 to Oct 31". "31 Sep 2016 to 31 Oct 2016".
     */
    public static boolean isValidStartDateToEndDateFormat(String dateString) {
    	Date[] dates = getStartAndEndDates(dateString);
    	// dates is null if dateString is not a valid format
    	if (dates == null) {
    		return false;
    	}
    	Date startDate = dates[0];
    	Date endDate = dates[1];
    	
    	// Format is valid only if end date is after the start date
    	return endDate.after(startDate);
    }

    /**
     * Retrieve the date from a string that represents some date using Natty library.
     */
    public static Date getDate(String dateString) {
    	// Add spaces between numbers and words in order for Natty to process it correctly
    	dateString = StringUtil.addSpacesBetweenNumbersAndWords(dateString).trim().toLowerCase();
    	String[] tokens = dateString.split(" ");
    	
    	// There should not be more than 3 tokens since there is only <day> <month> <year>
    	if (tokens.length > 3) {
    		return null;
    	}
    	
    	// Using the Natty library to parse the dateString
    	Parser parser = new Parser();
    	List<DateGroup> groups = parser.parse(dateString);

    	// String is valid date format only if there is only 1 DateGroup within
    	if (groups.size() != 1) {
    		return null;
    	}
    	DateGroup firstDateGroup = groups.get(0);
    	
    	// Date should be provided by user and not inferred.
    	if (firstDateGroup.isDateInferred()) {
    		return null;
    	}
    	
    	List<Date> dates = firstDateGroup.getDates();

    	// String is valid date format only if there is only 1 date value within
    	if (dates.size() != 1) {
    		return null;
    	}
    	return validateDateIsSensible(dates.get(0), dateString);
	}
    
    /**
     * After receiving a Date from Natty, do a sanity check to ensure that the Date given by Natty is sensible
     * and not overly flexible by taking the <day> value of the Date and making sure that it exists within the
     * tokens of a date string.
     * 
     * If the date is sensible, return the original date.
     * Else, return null.
     * 
     * Caution: This is just a heuristic to check if Natty processed properly
     */
    public static Date validateDateIsSensible(Date date, String dateString) {
    	String[] tokens = dateString.split(" ");
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		String day = Integer.toString(cal.get(Calendar.DAY_OF_MONTH));
		
    	for (String token : tokens) {
    		// Removes any 1st/2nd/3rd etc from the date input
    		if (token.replaceAll("st|nd|rd|th", "").equals(day)) {
    			return date;
    		}
    	}
    	return null;
    }
    
    /**
     * Retrieve the start date and end date from a string that says "from (start date) to/- (end date)".
     * Stores the dates in a Date[] with start date as the 1st value and end date as the 2nd value.
     */
	public static Date[] getStartAndEndDates(String dateString) {
		Date[] dates = new Date[2];
    	String[] splitByTo = dateString.split("(?![c])to(?![b])"); // Make sure "to" is not part of October
    	String[] splitByDash = dateString.split("-");
    	
    	// After splitting by "to" or "-", the String array must be of length 2 (hold start date and end date)
    	if (splitByTo.length == 2) {
    		dates[0] = getDate(splitByTo[0]);
    		dates[1] = getDate(splitByTo[1]);
    	} else if (splitByDash.length == 2) {
    		dates[0] = getDate(splitByDash[0]);
    		dates[1] = getDate(splitByDash[1]);
    	} else {
    		return null;
    	}
    	
    	// If either dates are null, it means that dateString is not a valid format, return null
		if (dates[0] == null || dates[1] == null) {
			return null;
		}
    	return dates;
	}
}
```
###### /java/seedu/address/logic/commands/taskcommands/AddTaskCommand.java
``` java
public class AddTaskCommand extends TaskCommand {

    public static final String COMMAND_WORD = "add";

    public static final String HELP_MESSAGE_USAGE = "Add a task: \t" + "add <description> \n" +
            "Add a deadline: \t" + "add <description> by <date> \n" +
            "Add an event: \t" + "add <description> from <startDate> to <endDate>";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to TaskManager. \n"
            + "1) Parameters: DESCRIPTION \n"
            + "Example: " + COMMAND_WORD
            + " Finish V0.1 \n"
            + "2) Parameters: DESCRIPTION by DEADLINE \n"
            + "Example: " + COMMAND_WORD
            + " Finish V0.1 by Oct 31 \n"
            + "3) Parameters: DESCRIPTION from START_DATE to END_DATE \n"
            + "Example: " + COMMAND_WORD
            + " Software Demo from Oct 31 to Nov 1";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in TaskManager";
    public static final String MESSAGE_EMPTY_TASK = "Description to AddTaskCommand constructor is empty.\n";

    private Task toAdd;

    /**
     * A FloatingTask has only one parameter, description.
     * This AddTaskCommand constructor takes in a description and adds a FloatingTask.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddTaskCommand(String description)
            throws IllegalValueException {
    	if (description == null || description.isEmpty()) {
    		throw new IllegalValueException(MESSAGE_EMPTY_TASK + MESSAGE_USAGE);
    	}
    	this.toAdd = new FloatingTask(description);
    }
    
    /**
     * A DeadlineTask has only two parameters, description and a deadline.
     * This AddTaskCommand constructor takes in a description and a deadline, and adds a DeadlineTask.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddTaskCommand(String description, Date deadline)
            throws IllegalValueException {
    	if (description == null || description.isEmpty()) {
    		throw new IllegalValueException("Description to AddTaskCommand constructor is empty.");
    	}
    	this.toAdd = new DeadlineTask(description, deadline);
    }
    
    /**
     * An EventTask has only three parameter, description, startDate and endDate.
     * This AddTaskCommand constructor takes in a description, startDate and endDate, and adds an EventTask.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddTaskCommand(String description, Date startDate, Date endDate)
            throws IllegalValueException {
    	if (description == null || description.isEmpty()) {
    		throw new IllegalValueException("Description to AddTaskCommand constructor is empty.");
    	}
    	this.toAdd = new EventTask(description, startDate, endDate);
    }
    
    /**
     * Retrieve the details of the task for testing purposes
     */
    public String getTaskDetails() {
    	return toAdd.toString();
    }
    
    /**
     * Retrieve the task to add
     */
    public Task getTask() {
    	return toAdd;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            model.clearTasksFilter();
            EventsCenter.getInstance().post(new HideHelpRequestEvent());
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateItemException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### /java/seedu/address/logic/commands/taskcommands/RedoTaskCommand.java
``` java
public class RedoTaskCommand extends TaskCommand {
    
    public static final String COMMAND_WORD = "redo";
    
    public static final String MESSAGE_REDO_TASK_SUCCESS = "Redo successful";
    public static final String MESSAGE_REDO_INVALID_STATE = "Redo is not successful because the previous successful command is not undo";

    public static final String HELP_MESSAGE_USAGE = COMMAND_WORD + ": \t redoes previous command.";
    
    public RedoTaskCommand() {}

    @Override
    public CommandResult execute() {
    	try {
    		model.redo();
    	} catch (IllegalStateException ise) {
    		return new CommandResult(MESSAGE_REDO_INVALID_STATE);
    	}
    	return new CommandResult(MESSAGE_REDO_TASK_SUCCESS);
    }
}
```
###### /java/seedu/address/logic/commands/taskcommands/UndoTaskCommand.java
``` java
public class UndoTaskCommand extends TaskCommand {
    
    public static final String COMMAND_WORD = "undo";
    
    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo successful";
    public static final String MESSAGE_UNDO_INVALID_STATE = "Undo is not successful because there is no previous command";
    
    public UndoTaskCommand() {}

    @Override
    public CommandResult execute() {
    	try {
    		model.undo();
    	} catch (IllegalStateException ise) {
    		return new CommandResult(MESSAGE_UNDO_INVALID_STATE);
    	}
    	return new CommandResult(MESSAGE_UNDO_TASK_SUCCESS);
    }
}
```
###### /java/seedu/address/logic/commands/taskcommands/UpdateTaskCommand.java
``` java
public class UpdateTaskCommand extends TaskCommand {

	public static final String COMMAND_WORD = "update";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the task identified by the index number used in the last task listing.\n"
            + "Depending on whether 'task', 'description' or 'date' is stated, the task will be updated accordingly.\n"
            + "1) Parameters: INDEX (must be a positive integer) task UPDATED_VALUE\n"
            + "Example: " + COMMAND_WORD + " 1 task Meeting from Oct 31 to Nov 1\n"
            + "2) Parameters: INDEX (must be a positive integer) description UPDATED_VALUE\n"
            + "Example: " + COMMAND_WORD + " 1 description Meeting in town\n"
            + "3) Parameters: INDEX (must be a positive integer) date UPDATED_VALUE\n"
            + "Example: " + COMMAND_WORD + " 1 date Oct 31 to Nov 1";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated task: %1$s";
    public static final String MESSAGE_CANNOT_UPDATE_TASK = "Selected task's description cannot be updated";
    
    public static final String TASK_DETAILS_UPDATE_TASK = "[Update Task][Task: %s]";
    public static final String TASK_DETAILS_UPDATE_DESCRIPTION = "[Update Task][Description: %s]";
    public static final String TASK_DETAILS_UPDATE_DEADLINE = "[Update Task][Deadline: %s]";
    public static final String TASK_DETAILS_UPDATE_START_END_DATE = "[Update Task][Start date: %s][End date: %s]";
    
    public final int targetIndex;
    private Task updatedTask;
    
    // Values that are to be updated. If it is not supposed to be updated, it will be null
    private Task newTask;
    private Description newDescription;
    private Date newDeadline;
    private Date newStartDate;
    private Date newEndDate;

    /**
     * This constructor is called by the user enters a command to replace the entire task.
     * 
     * Example: update 1 task Homework by 31 Oct 2016
     * (Replaces whatever task at index 1 to be a DeadlineTask with description as "Homework" and deadline by 31 Oct 2016)
     */
    public UpdateTaskCommand(int targetIndex, Task newTask) {
        this.targetIndex = targetIndex;
        this.newTask = newTask;
    }
    
    /**
     * This constructor is called by the user enters a command to update the description of a task.
     * 
     * Example: update 1 description Meeting
     * (Changes the description of the task at index 1 to be "Meeting")
     */
    public UpdateTaskCommand(int targetIndex, Description newDescription) {
        this.targetIndex = targetIndex;
        this.newDescription = newDescription;
    }
    
    /**
     * This constructor is called by the user enters a command to update the deadline of a task.
     * 
     * Example: update 1 date 31 Oct
     * (Changes the task at index 1 to have a deadline of 31 Oct 2016 (Whether or not it is a deadline task))
     */
    public UpdateTaskCommand(int targetIndex, Date newDeadline) {
        this.targetIndex = targetIndex;
        this.newDeadline = newDeadline;
    }
    
    /**
     * This constructor is called by the user enters a command to update the start date and end date of a task.
     * 
     * Example: update 1 date 31 Oct to 1 Nov
     * (Changes the task at index 1 to have a start date of 31 Oct and end date of 1 Nov (Whether or not it is an event task))
     */
    public UpdateTaskCommand(int targetIndex, Date newStartDate, Date newEndDate) {
        this.targetIndex = targetIndex;
        this.newStartDate = newStartDate;
        this.newEndDate = newEndDate;
    }
    
    /**
     * Given the task that is to be updated, create a new updatedTask to replace it
     * by retrieving the values to be updated
     */
    public void prepareUpdatedTask(Task taskToUpdate) throws IllegalValueException {
    	if (newTask != null) {
    		// User wants to change the entire task
    		updatedTask = newTask;
    		
    	} else if (newDescription != null) {
    		// User wants to change just the description
    		updatedTask = prepareUpdatedDescriptionForTask(taskToUpdate);
    		
    	} else if (newDeadline != null) {
    		// User wants to change the deadline of a Task
    		updatedTask = prepareUpdatedDeadlineForTask(taskToUpdate);

    	} else if ((newStartDate != null && newEndDate != null)) {
    		// User wants to change the start date and end date of a Task
    		updatedTask = prepareUpdatedStartEndDateForTask(taskToUpdate);
    		
    	} else {
    		assert false : "At least task, description or date should have new values";
    	}
    	
    	// Retain favorite status
		if (taskToUpdate.isFavorite()) {
			updatedTask.setAsFavorite();
		}
    }
    
    /**
     * Create a new task with a different description to replace taskToUpdate
     */
    public Task prepareUpdatedDescriptionForTask(Task taskToUpdate) throws IllegalValueException {
    	// Return a new Task based on the type of the task to be updated
		if (taskToUpdate instanceof FloatingTask) {
			return new FloatingTask(newDescription.getContent());
			
		} else if (taskToUpdate instanceof DeadlineTask) {
			DeadlineTask task = (DeadlineTask) taskToUpdate;
			return new DeadlineTask(newDescription.getContent(), task.getDeadline());
			
		} else if (taskToUpdate instanceof EventTask) {
			EventTask task = (EventTask) taskToUpdate;
			return new EventTask(newDescription.getContent(), task.getStartDate(), task.getEndDate());	
		
		} else {
			throw new IllegalValueException(MESSAGE_CANNOT_UPDATE_TASK);
		}	
    }
    
    /**
     * Create a new task with a different deadline to replace taskToUpdate
     */
    public Task prepareUpdatedDeadlineForTask(Task taskToUpdate) throws IllegalValueException {
    	// Create a deadline task to replace the original task
    	String description = taskToUpdate.getDescription().getContent();
		return new DeadlineTask(description, newDeadline);
    }
    
    /**
     * Create a new task with a different start and end date to replace taskToUpdate
     */
    public Task prepareUpdatedStartEndDateForTask(Task taskToUpdate) throws IllegalValueException {
    	// Create an event task to replace the original task
    	String description = taskToUpdate.getDescription().getContent();
		return new EventTask(description, newStartDate, newEndDate);
    }
    
    /**
     * Retrieve the details of the values to be updated for testing purposes
     */
    public String getTaskDetails() {
    	if (newTask != null) {
    		return String.format(TASK_DETAILS_UPDATE_TASK, newTask);
    	} else if (newDescription != null) {
    		return String.format(TASK_DETAILS_UPDATE_DESCRIPTION, newDescription);
    	} else if (newDeadline != null) {
    		return String.format(TASK_DETAILS_UPDATE_DEADLINE,
    				DateUtil.dateFormat.format(newDeadline));
    	} else if (newStartDate != null && newEndDate != null) {
    		return String.format(TASK_DETAILS_UPDATE_START_END_DATE, 
    				DateUtil.dateFormat.format(newStartDate), DateUtil.dateFormat.format(newEndDate));
    	} else {
    		return "Error";
    	}
    }


    @Override
    public CommandResult execute() {

	    ObservableList<Task> lastShownList = model.getCurrentFilteredTasks();

        if (lastShownList.size() < targetIndex || targetIndex <= 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        Task taskToUpdate = lastShownList.get(targetIndex - 1);

        try {
        	prepareUpdatedTask(taskToUpdate);
            model.updateTask(taskToUpdate, updatedTask);
        } catch (DuplicateItemException die) {
        	assert false : "Deletion of the original task (before addition of an updated task) has failed";
        } catch (IllegalValueException ive) {
        	return new CommandResult(ive.getMessage());
        } catch (ItemNotFoundException tnfe) {
            assert false : "The target item cannot be missing";
        } 

        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, updatedTask));
    }

}
```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends TaskCommand {
    
    public static final String COMMAND_WORD = "undo";
    
    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo successful";
    public static final String MESSAGE_UNDO_INVALID_STATE = "Undo is not successful because there is no previous command";

    public static final String HELP_MESSAGE_USAGE = COMMAND_WORD + ": \t undoes previous command.";
    
    public UndoCommand() {}

    @Override
    public CommandResult execute() {
    	try {
    		model.undo();
    	} catch (IllegalStateException ise) {
    		return new CommandResult(MESSAGE_UNDO_INVALID_STATE);
    	}
    	return new CommandResult(MESSAGE_UNDO_TASK_SUCCESS);
    }
}
```
###### /java/seedu/address/logic/parser/AddCommandParser.java
``` java
public class AddCommandParser extends CommandParser{
    public static final String COMMAND_WORD = AddTaskCommand.COMMAND_WORD;
	/**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	public TaskCommand prepareCommand(String arguments) {
		try {
			// Call the appropriate AddTaskCommand constructor based on the arguments
			return createAppropriateAddTaskCommand(arguments);
		} catch (IllegalValueException ive) {
            return new IncorrectTaskCommand(ive.getMessage());
        }
	}
	
	/**
     * Based on the description for the add command, determines if it is a FloatingTask, DeadlineTask or EventTask to be added.
     * Then, return the appropriate addTaskCommand by calling the corresponding constructor.
     */
    private AddTaskCommand createAppropriateAddTaskCommand(String description)
    			throws IllegalValueException {
    	// If there are double inverted commas at the start and end, it means that it is a FloatingTask
    	if (description.length() > 1 && description.endsWith("\"") && description.startsWith("\"")) {
    		return new AddTaskCommand(description);
    	}
    	
    	// Determine if it is DeadlineTask (which has "by") or EventTask (which has "from")
    	// Spaces needed before "from" and "by" to ensure they are separate words
    	int indexOfLastFrom = description.lastIndexOf(" from ");
    	int indexOfLastBy = description.lastIndexOf(" by ");
    	boolean fromWordIsAbsent = (indexOfLastFrom == -1);
    	boolean byWordIsAbsent = (indexOfLastBy == -1);
    	
    	if (fromWordIsAbsent && byWordIsAbsent) {
    		// If both words are not present, it means that it is a FloatingTask
    		return new AddTaskCommand(description);
    		
    	} else if (fromWordIsAbsent) {
    		// If only "by" exists, task is a DeadlineTask if the sentence after "by" is a valid date format
    		return createAddTaskCommandBasedOnDateString(description, indexOfLastBy, " by ");
    		
    	} else if (byWordIsAbsent) {
    		// If only "from" exists, task is an EventTask if the sentence after "from" is a valid date format
    		return createAddTaskCommandBasedOnDateString(description, indexOfLastFrom, " from ");
    		
    	} else if (indexOfLastFrom > indexOfLastBy) {
    		// Both indices exist, the one that comes later will be picked. If "from" came later.
    		return createAddTaskCommandBasedOnDateString(description, indexOfLastFrom, " from ");
    			
    	} else {
    		// If "by" came later.
    		return createAddTaskCommandBasedOnDateString(description, indexOfLastBy, " by ");

    	}
    }
    
    /**
     * Checks if the string from "substringFrom" to the end of description corresponds to a valid date format or 
     * a valid start date to end date format.
     * 
     * With the results, decide whether the task to add is a DeadlineTask, EventTask or FloatingTask.
     */
    private AddTaskCommand createAddTaskCommandBasedOnDateString(String description, int substringFrom, String keyword) 
    			throws IllegalValueException {
    	// Separate description into task description and the date string
    	String taskDescription = description.substring(0, substringFrom).trim();
    	String dateString = description.substring(substringFrom + keyword.length(), description.length()).trim();
    	
    	if (keyword.equals(" by ") && DateUtil.isValidDateFormat(dateString)) {
    		// dateString represents task's deadline
    		Date deadline = DateUtil.getDate(dateString);
			return new AddTaskCommand(taskDescription, deadline);
			
    	} else if (keyword.equals(" from ") && DateUtil.isValidStartDateToEndDateFormat(dateString)) {	
			// dateString represents task's start date and end date
    		Date[] startAndEndDates = DateUtil.getStartAndEndDates(dateString);
    		Date startDate = startAndEndDates[0];
    		Date endDate = startAndEndDates[1];
			return new AddTaskCommand(taskDescription, startDate, endDate);
			
		} else {
			// Floating task since sentence after "from" is not a valid date
			return new AddTaskCommand(description);
		}
    }
}
```
###### /java/seedu/address/logic/parser/RedoCommandParser.java
``` java
public class RedoCommandParser extends CommandParser{
    public static final String COMMAND_WORD = RedoTaskCommand.COMMAND_WORD;

    @Override
    public TaskCommand prepareCommand(String arguments) {
        return new RedoTaskCommand();
    }
}
```
###### /java/seedu/address/logic/parser/UndoCommandParser.java
``` java
public class UndoCommandParser extends CommandParser{
    public static final String COMMAND_WORD = UndoTaskCommand.COMMAND_WORD;

    @Override
    public TaskCommand prepareCommand(String arguments) {
        return new UndoTaskCommand();
    }
}
```
###### /java/seedu/address/logic/parser/UpdateCommandParser.java
``` java
public class UpdateCommandParser extends CommandParser {
	public static final String COMMAND_WORD = UpdateTaskCommand.COMMAND_WORD;
    private static final Pattern UPDATE_COMMAND_FORMAT = Pattern.compile("(?<targetIndex>\\S+) (?<updateType>\\S+) (?<arguments>.+)");
    private Matcher matcher;
    
    public static final String MESSAGE_INVALID_UPDATE_TYPE = "Update type must be either task, description or date\n Examples: \n"
    		+ "1) update INDEX task Meeting with colleagues by 20 Oct \n"
    		+ "2) update INDEX description \n"
    		+ "3) update INDEX date 20 Oct to 31 Oct";
    
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	public TaskCommand prepareCommand(String arguments) {
		TaskCommand taskCommand;
		
		// Matches the arguments to the update command format
        matcher = UPDATE_COMMAND_FORMAT.matcher(arguments.trim());
        
        // Checks validity of index and update type using the matcher
        taskCommand = checkIndexAndUpdateType();
        if (taskCommand != null) {
        	return taskCommand;
        }

        try {
	        // Creates an appropriate UpdateTaskCommand or IncorrectTaskCommand using the matcher
		    taskCommand = createAppropriateTaskCommand();
        } catch (IllegalValueException ive) {
        	return new IncorrectTaskCommand(ive.getMessage());
        }
	    
	    return taskCommand;
	}
	
	/**
	 * Based on the arguments provided to the update command, determine if the user wants to change
	 * the task, description or date.
	 * Then, return the appropriate UpdateTaskCommand by calling the corresponding constructor or
	 * the IncorrectTaskCommand.
	 */
	private TaskCommand createAppropriateTaskCommand() throws IllegalValueException {
		TaskCommand taskCommand = null;
		int index = Integer.parseInt(matcher.group("targetIndex"));
		String updateType = matcher.group("updateType");
		String arguments = matcher.group("arguments");
		
		// Depending on the update type, choose an appropriate TaskCommand
		if (updateType.equals("task")) {
			taskCommand = createTaskUpdateTaskCommand(index, arguments);
			
		} else if (updateType.equals("description")) {
			taskCommand = createDescriptionUpdateTaskCommand(index, arguments);
			
		} else if (updateType.equals("date")) {
			taskCommand = createDateUpdateTaskCommand(index, arguments);
			
		} else {
			assert false : MESSAGE_INVALID_UPDATE_TYPE;
		}
		
		return taskCommand;
	}
	
	/**
	 * Creates an UpdateTaskCommand to update the entire task
	 */
	private TaskCommand createTaskUpdateTaskCommand(int index, String arguments) throws IllegalValueException {
		// Use AddCommandParser to create the new task that the user wants
		AddCommandParser parser = new AddCommandParser();
		Task task = ((AddTaskCommand) parser.prepareCommand(arguments)).getTask();
		return new UpdateTaskCommand(index, task);
	}
	
	/**
	 * Creates an UpdateTaskCommand to update the description
	 */
	private TaskCommand createDescriptionUpdateTaskCommand(int index, String arguments) throws IllegalValueException {
		Description description = new Description(arguments);
		return new UpdateTaskCommand(index, description);
	}
	
	/**
	 * Creates an UpdateTaskCommand to update the date
	 */
	private TaskCommand createDateUpdateTaskCommand(int index, String arguments) throws IllegalValueException {
		// Check if the arguments that the user provided is a valid date or a valid date range.
		// Then, call the appropriate UpdateTaskCommands or throw an exception (if date is invalid).
		if (DateUtil.isValidDateFormat(arguments)) {
			Date newDeadline = DateUtil.getDate(arguments);
			return new UpdateTaskCommand(index, newDeadline);
			
		} else if (DateUtil.isValidStartDateToEndDateFormat(arguments)) {
    		Date[] startAndEndDates = DateUtil.getStartAndEndDates(arguments);
    		Date newStartDate = startAndEndDates[0];
    		Date newEndDate = startAndEndDates[1];
			return new UpdateTaskCommand(index, newStartDate, newEndDate);
			
		} else {
			throw new IllegalValueException(MESSAGE_INVALID_DATE_FORMAT);
		}
	}
	
	/**
	 * Determines if the index and update type is valid. If it is, return null.
	 * Else, return an IncorrectTaskCommand.
	 */
	private IncorrectTaskCommand checkIndexAndUpdateType() {
		if (!matcher.matches()) {
            return new IncorrectTaskCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateTaskCommand.MESSAGE_USAGE));
        }

        // Check if the index that user gave is valid
        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return new IncorrectTaskCommand(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        // Check if the updateType that user gave is valid
        String updateType = matcher.group("updateType");
        if(!updateType.equals("task") && !updateType.equals("description") && !updateType.equals("date")) {
        	return new IncorrectTaskCommand(MESSAGE_INVALID_UPDATE_TYPE);
        }
        return null;
	}
}
```
###### /java/seedu/address/model/Copiable.java
``` java
public interface Copiable<T> {
	/**
	 * This class allows the instance of another class to be copied to return a new instance of that class.
	 */
	 public T copy();
}
```
###### /java/seedu/address/model/ModelHistory.java
``` java
public class ModelHistory {
	// Collection to store the tasks / aliases after each command that changes tasks or aliases. Allows user to undo.
	private UniqueItemCollection<Task> oldTasks;
	private UniqueItemCollection<Alias> oldAliases;
	 
	// Collection to store the current tasks / aliases before an undo command. Allows user to redo.
	private UniqueItemCollection<Task> undoneTasks;
	private UniqueItemCollection<Alias> undoneAliases;
	
	public ModelHistory() {}
	
	
	// ============================ Supporting Undo ============================
	
	/**
	 * Stores the list of old tasks so that undo can be called later.
	 */
	public void storeOldTasks(UniqueItemCollection<Task> oldCopy) {
		oldTasks = oldCopy;
		oldAliases = null; // Null to signal that aliases have not been changed
		
		// No tasks and aliases have been undone
		undoneTasks = null;
		undoneAliases = null;
	}
	
	/**
	 * If oldTasks exist, it means that there are tasks to be undone
	 */
	public boolean canUndoTasks() {
		return oldTasks != null;
	}
	
	/**
	 * Stores the list of old aliases so that undo can be called later.
	 */
	public void storeOldAliases(UniqueItemCollection<Alias> oldCopy) {
		oldAliases = oldCopy;
		oldTasks = null; // Null to signal that tasks have not been changed
		
		// No tasks and aliases have been undone
		undoneTasks = null;
		undoneAliases = null;
	}
	
	/**
	 * If oldAliases exist, it means that there are aliases to be undone
	 */
	public boolean canUndoAliases() {
		return oldAliases != null;
	}
	
	/**
	 * Clear old copies of aliases and tasks after undo
	 */
	public void clearOldCopies() {
		// Can only undo once. Hence, oldTasks & oldAliases are set to null after one undo
		oldAliases = null;
		oldTasks = null;
	}
	
	/**
	 * Returns oldTasks which is the old state of the task list,
	 * Stores current value in undoneTasks in case user wants to reverse the undo (redo)
	 */
	public UniqueItemCollection<Task> undoTasks(UniqueItemCollection<Task> currentTasks) {
		// Before undoing task, undoneTasks is assigned the current list of tasks to allow user to redo
		undoneTasks = currentTasks;
		// Since no alias have been undone, undoneAliases set to null
		undoneAliases = null;
		
		// Return the old copy of tasks
		return oldTasks;
	}
	
	/**
	 * Returns oldAliases which is the old state of the alias list,
	 * Stores current value in undoneAliases in case user wants to reverse the undo (redo)
	 */
	public UniqueItemCollection<Alias> undoAliases(UniqueItemCollection<Alias> currentAliases) {
		// Before undoing task, undoneAliases is assigned the current list of tasks to allow user to redo
		undoneAliases = currentAliases;
		// Since no alias have been undone, undoneTasks set to null
		undoneTasks = null;
		
		// Return the old copy of Aliases
		return oldAliases;
	}
	
	// ============================ Supporting Redo ============================
	
	/**
	 * Stores the list of tasks that have been undone (so that redo can be called later).
	 */
	public void storeUndoneTasks(UniqueItemCollection<Task> currentCopy) {
		undoneTasks = currentCopy;
		undoneAliases = null; // Null to signal that aliases have not been undone
		
		// No tasks and aliases have been changed
		oldTasks = null;
		oldAliases = null;
	}
	
	/**
	 * If undoneTasks exist, it means that there are tasks to be redone
	 */
	public boolean canRedoTasks() {
		return undoneTasks != null;
	}
	
	/**
	 * Stores the list of aliases that have been undone (so that redo can be called later).
	 */
	public void storeUndoneAliases(UniqueItemCollection<Alias> currentCopy) {
		undoneAliases = currentCopy; 
		undoneTasks = null; // Null to signal that task have not been undone
		
		// No tasks and aliases have been changed
		oldTasks = null;
		oldAliases = null;
	}
	
	/**
	 * If undoneAliases exist, it means that there are aliases to be redone
	 */
	public boolean canRedoAliases() {
		return undoneAliases != null;
	}
	
	/**
	 * Clear copies of undone aliases and tasks after redo
	 */
	public void clearUndoneCopies() {
		// Can only redo once. Hence, undoneTasks & undoneAliases are set to null after one redo
		undoneAliases = null;
		undoneTasks = null;
	}
	
	/**
	 * Returns undoneTasks which is the state of the task list before 'undo' has been called,
	 * Stores current value in oldTasks in case user wants to reverse the redo (undo)
	 */
	public UniqueItemCollection<Task> redoTasks(UniqueItemCollection<Task> currentTasks) {
		// Before redoing task, oldTasks is assigned the current list of tasks to allow user to undo
		oldTasks = currentTasks;
		// Since no alias have been redone, oldAliases set to null
		oldAliases = null;
		
		// Return the tasks before undo has been called
		return undoneTasks;
	}
	
	/**
	 * Returns oldAliases which is the old state of the alias list,
	 * Stores current value in undoneAliases in case user wants to reverse the undo (redo)
	 */
	public UniqueItemCollection<Alias> redoAliases(UniqueItemCollection<Alias> currentAliases) {
		// Before undoing task, undoneAliases is assigned the current list of tasks to allow user to redo
		oldAliases = currentAliases;
		// Since no alias have been redone, undoneTasks set to null
		oldTasks = null;
		
		// Return the aliases before undo has been called
		return undoneAliases;
	}
	
}
```
###### /java/seedu/address/model/task/DatedTask.java
``` java
public interface DatedTask {
	// Format for displaying dates
	SimpleDateFormat dateFormat = new SimpleDateFormat("dd.MM.yyyy");
}
```
###### /java/seedu/address/model/task/DeadlineTask.java
``` java
public class DeadlineTask extends Task implements FavoritableTask, CompletableTask, DatedTask {

	private Date deadline;

	public DeadlineTask(String descriptionText, Date deadline) {
		this.description = new Description(descriptionText);
		this.deadline = deadline;
	}
		
	public Date getDeadline() {
		return deadline;
	}
	
	@Override
	public DeadlineTask copy() {
		String newDescription = this.description.getContent();
		Date newDeadline = new Date(this.deadline.getTime());
		DeadlineTask newTask = new DeadlineTask(newDescription, newDeadline);
		
		// Copy favorite status
		if (this.isFavorite()) {
			newTask.setAsFavorite();
		} else {
			newTask.setAsNotFavorite();
		}
		
		// Copy completed status
		if (this.isComplete()) {
			newTask.setAsComplete();
		} else {
			newTask.setAsUncomplete();
		}
		return newTask;
	}
	
	@Override
	public String toString() {
		return String.format("[Deadline Task][Description: %s][Deadline: %s]", 
				description, dateFormat.format(deadline));
	}
}
```
###### /java/seedu/address/model/task/EventTask.java
``` java
public class EventTask extends Task implements FavoritableTask, CompletableTask, DatedTask {

	private Date startDate;
	private Date endDate;

	public EventTask(String descriptionText, Date startDate, Date endDate) {
		this.description = new Description(descriptionText);
		this.startDate = startDate;
		this.endDate = endDate;
	}
	

	public Date getStartDate() {
		return startDate;
	}
	
	public Date getEndDate() {
		return endDate;
	}
	
	@Override
	public EventTask copy() {
		String newDescription = this.description.getContent();
		Date newStartDate = new Date(this.startDate.getTime());
		Date newEndDate = new Date(this.endDate.getTime());
		EventTask newTask = new EventTask(newDescription, newStartDate, newEndDate); 
		
		// Copy favorite status
		if (this.isFavorite()) {
			newTask.setAsFavorite();
		} else {
			newTask.setAsNotFavorite();
		}
		
		// Copy completed status
		if (this.isComplete()) {
			newTask.setAsComplete();
		} else {
			newTask.setAsUncomplete();
		}
		
		return newTask;
	}
	
	@Override
	public String toString() {
		return String.format("[Event Task][Description: %s][Start date: %s][End date: %s]", 
				description, dateFormat.format(startDate), dateFormat.format(endDate));
	}
}
```
###### /java/seedu/address/model/task/TaskManager.java
``` java
	@Override
	public void undo() throws IllegalStateException {
		// Undoing task type command
		if (modelHistory.canUndoTasks()) {
			// Current values of tasks passed to undoManager to be stored to allow user to redo.
			// Tasks that will replace the current list is returned.
			UniqueItemCollection<Task> replacingTasks = modelHistory.undoTasks(tasks);
			
			// The current tasks have been reinstated to their older versions
			tasks = replacingTasks;
			
		// Undoing alias type command
		} else if (modelHistory.canUndoAliases()) {
			// Current values of aliases passed to undoManager to be stored to allow user to redo.
			// Aliases that will replace the current list is returned
			UniqueItemCollection<Alias> replacingAliases = modelHistory.undoAliases(aliases);
			
			// The current aliases have been reinstated to their older versions
			aliases = replacingAliases;
			
		} else { 
			throw new IllegalStateException("Unable to undo because there is no previous state to revert to"); 
		}
		// Clear old values of tasks & aliases
		modelHistory.clearOldCopies();
		
		// Save the old predicate before we reassign filteredTasks
		Predicate<? super Task> currentPredicate = filteredTasks.getPredicate();
		
		// Refresh the filtered tasks
		filteredTasks = new FilteredList<>(tasks.getInternalList());
		
		// Reapply the predicate
		filteredTasks.setPredicate(currentPredicate);
		
		// Raise the changes
		indicateNewTaskListEvent();
		indicateAliasChanged();
	}
	
	/**
	 * Redoes the command that has been undone
	 * (Can only be called if the previous successful command was a successful undo command)
	 */
```
###### /java/seedu/address/model/task/TaskManager.java
``` java
	@Override
	public void redo() throws IllegalStateException {
		// Redoing task type command
		if (modelHistory.canRedoTasks()) {
			// Current values of tasks passed to undoManager to be stored to allow user to undo.
			// Tasks that will replace the current list is returned.
			UniqueItemCollection<Task> replacingTasks = modelHistory.redoTasks(tasks);
			
			// The current tasks have been reinstated to the versions before 'undo' has been called
			tasks = replacingTasks;
			
		// Undoing alias type command
		} else if (modelHistory.canRedoAliases()) {
			// Current values of aliases passed to undoManager to be stored to allow user to undo.
			// Aliases that will replace the current list is returned
			UniqueItemCollection<Alias> replacingAliases = modelHistory.redoAliases(aliases);
			
			// The current aliases have been reinstated to the versions before 'undo' has been called
			aliases = replacingAliases;
			
		} else { 
			throw new IllegalStateException("Unable to redo because the previous successful command was not an undo command"); 
		}
		// Clear values of tasks & aliases that have been stored due to 'undo'
		modelHistory.clearUndoneCopies();
		
		// Save the old predicate before we reassign filteredTasks
		Predicate<? super Task> currentPredicate = filteredTasks.getPredicate();
		
		// Refresh the filtered tasks
		filteredTasks = new FilteredList<>(tasks.getInternalList());
		
		// Reapply the predicate
		filteredTasks.setPredicate(currentPredicate);
		
		// Raise the changes
		indicateNewTaskListEvent();
		indicateAliasChanged();
	}
```
