# A0138978E
###### /java/w15c2/tusk/commons/util/StringUtil.java
``` java
    private static final String REGEX_CHARS_FOLLOWED_BY_DATECHARS = "([a-zA-Z]+)(\\d+)(?!st|nd|rd|th)";
    private static final String REGEX_DIGIT_FOLLOWED_BY_DATECHARS = "(\\d+)(?!st|nd|rd|th)([a-zA-Z]+)";

```
###### /java/w15c2/tusk/commons/util/StringUtil.java
``` java
    /**
     * Returns a string where spaces are added between
     * word-character and character-word boundaries
     * E.g. 31Oct2016 -> 31 Oct 2016
     * @param s the original string with numbers and words possibly
     * @return a string with spaces between numbers and words
     */
    public static String addSpacesBetweenNumbersAndWords(String s) {
    	if (s == null) return null;
    	
    	s = s.replaceAll(REGEX_DIGIT_FOLLOWED_BY_DATECHARS, "$1 $2");
    	s = s.replaceAll(REGEX_CHARS_FOLLOWED_BY_DATECHARS, "$1 $2");
    	return s;

    }
}
```
###### /java/w15c2/tusk/commons/core/TaskConfig.java
``` java
    /**
     * Modifes the task and alias storage file path based on the new storage location provided.
     * @param storageLocation new storage location for task and alias files
     */
    public void setStorageLocation(String storageLocation) {
    	this.setTasksFilePath(Paths.get(storageLocation, tasksFileName).toString());
    	this.setAliasFilePath(Paths.get(storageLocation, aliasFileName).toString());
    }


    @Override
    /**
     * Checks equality with any other task config object by comparing essential fields.
     * @param other the object to compare to
     */
    public boolean equals(Object other) {
        if (other == this){
            return true;
        }
        if (!(other instanceof TaskConfig)){ //this handles null as well.
            return false;
        }

        TaskConfig o = (TaskConfig)other;

        return Objects.equals(appTitle, o.appTitle)
                && Objects.equals(logLevel, o.logLevel)
                && Objects.equals(userPrefsFilePath, o.userPrefsFilePath)
                && Objects.equals(tasksFilePath, o.tasksFilePath)
                && Objects.equals(aliasFilePath, o.aliasFilePath)
                && Objects.equals(taskManagerName, o.taskManagerName);
    }

```
###### /java/w15c2/tusk/commons/events/storage/StorageChangedEvent.java
``` java
/**
 * Indicates that the storage location has changed
 */
public class StorageChangedEvent extends BaseEvent {

	String storagePath;
	
    public StorageChangedEvent(String storagePath) {
        this.storagePath = storagePath;
    }
    
    public String getStoragePath() {
    	return storagePath;
    }

    @Override
    public String toString(){
        return storagePath;
    }

}
```
###### /java/w15c2/tusk/commons/collections/UniqueItemCollection.java
``` java
/*
 * Defines a list where every item must be referentially different from every other item (no duplicate objects)
 */
public class UniqueItemCollection<T> implements Iterable<T>{
	
	/**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateItemException extends DuplicateDataException {
        public DuplicateItemException() {
            super("Operation would result in duplicate items");
        }
    }

    
    /**
     * Signals that an operation targeting a specified item in the list would fail because
     * there is no such matching item in the list.
     */
    public static class ItemNotFoundException extends Exception {}

    private final ObservableList<T> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty ItemCollection.
     */
    public UniqueItemCollection() {}
    
```
###### /java/w15c2/tusk/commons/collections/UniqueItemCollection.java
``` java
    /**
     * Returns true if the list contains an equivalent item as the given argument.
     * @param toCheck the item to check
     * @return if the list contains an equivalent item
     */
    public boolean contains(T toCheck) {
        if (toCheck == null) {
            return false;
        }
        
        // Force reference equality in the internal list
        return internalList.stream().anyMatch(obj -> obj == toCheck);
    }

    /**
     * Adds a item to the list.
     *@param toAdd item to add
     * @throws DuplicateItemException if the item to add is a duplicate of an existing item in the list.
     */
    public void add(T toAdd) throws DuplicateItemException {
        assert toAdd != null;
        
        if (contains(toAdd)) {
            throw new DuplicateItemException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent item from the list.
     * @param toRemove item to remove
     * @throws ItemNotFoundException if no such item could be found in the list.
     */
    public boolean remove(T toRemove) throws ItemNotFoundException {
        assert toRemove != null;
        final boolean itemFoundAndDeleted = internalList.remove(toRemove);
        if (!itemFoundAndDeleted) {
            throw new ItemNotFoundException();
        }
        return itemFoundAndDeleted;
    }
    
```
###### /java/w15c2/tusk/commons/collections/UniqueItemCollection.java
``` java
    public ObservableList<T> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<T> iterator() {
        return internalList.iterator();
    }

    @Override
    /**
     * Check for reference equality, then compare equality element-wise
     */
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueItemCollection// instanceof handles nulls
                && this.internalList.equals(
                ((UniqueItemCollection<T>) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### /java/w15c2/tusk/ui/TaskListPanel.java
``` java
    /**
     * Consume all events except for scrolling and scrollevents from control up/down
     */
    private void setSelectableCharacteristics() {
    	taskListView.addEventFilter(Event.ANY, new EventHandler<Event>() {
            @Override
            public void handle(Event event) {
               EventType<?> type = event.getEventType().getSuperType();
               if (type != ScrollEvent.ANY && type != ScrollToEvent.ANY) {
                   event.consume();
               } 
            }
    	});
	}

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
        });
    }
    
    /**
     * Scrolls halfway down the current task list view
     */
    public void scrollDown() {
    	Pair<Integer, Integer> firstAndLast = getFirstAndLastVisibleIndices(taskListView);
    	int firstIdx = firstAndLast.getKey();
    	int lastIdx = firstAndLast.getValue();
    	int middleIdx = (firstIdx + lastIdx) / 2;
    	
    	logger.info("First Idx: " + firstIdx + " Last Idx: " + lastIdx + " Middle Idx: " + middleIdx);
    	logger.info("Scrolling to item: " + middleIdx);
    	
    	// Scroll to the middle
    	scrollTo(middleIdx);
    }
    
    /**
     * Scrolls to the top of the current task list view plus some buffer
     */
    public void scrollUp() {
    	Pair<Integer, Integer> firstAndLast = getFirstAndLastVisibleIndices(taskListView);
    	int firstIdx = firstAndLast.getKey();
    	int lastIdx = firstAndLast.getValue();
    	int middleIdx = (firstIdx + lastIdx) / 2;
    	
    	int targetIdx = firstIdx - (middleIdx - firstIdx);
    	
    	logger.info("First Idx: " + firstIdx + " Last Idx: " + lastIdx + " Middle Idx: " + middleIdx);
    	logger.info("Scrolling to item: " + targetIdx);
    	// Scroll to the top plus some
    	scrollTo(targetIdx);
    }
    
```
###### /java/w15c2/tusk/ui/TaskListPanel.java
``` java
        @Override
        /**
         * Updates the task card's visual style based on the type of task it represents
         */
        protected void updateItem(Task task, boolean empty) {
            super.updateItem(task, empty);
            
            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } 
            else {
            	TaskCard currentCard = TaskCard.load(task, getIndex() + 1);
            	HBox cardPane = currentCard.getLayout();
               
            	setGraphic(cardPane);
            	
            	if (task.isPinned() && !task.isCompleted()) {
            		// Set the color of the card based on whether its favorited
                	currentCard.setPinnedStyle();
            	} else if (task.isCompleted()) {
                	// Set the color of the card based on whether its completed
                	currentCard.setCompletedStyle();
            	} else if (task.isOverdue()) {
            		// Set the color of the card based on whether its overdue
            		currentCard.setOverdueStyle();
            	} else {
                	// Normal card
                	currentCard.setNormalStyle();
                }	
            }
        }
    }

}
```
###### /java/w15c2/tusk/ui/CommandBox.java
``` java
    
    /** 
     * Indicates if the commandbox text has changed, and the 
     * source of the change was not the autocomplete function. This means
     * that the autocomplete source must be changed and the matches
     * found again.
     */
    private boolean hasTextChangedForAutocomplete = true;
    
    /**
     * A named listener for text in the command box changing.
     * This function is named so that it can be specifically removed and re-added as a listener
     * during the autocomplete function.
     */
	private final ChangeListener<? super String> textChangedListener = (observable, newVal, oldVal) -> {
		hasTextChangedForAutocomplete = true;
	};
	
```
###### /java/w15c2/tusk/ui/CommandBox.java
``` java
    private void setKeyListener() {
    	commandTextField.setOnKeyPressed(keyListener);
    }
    
    /**
     * Handles Up/Down keys to replace commandbox content with previous/next commands.
     * Makes sure that this isn't part of a control-up/down combination.
     * Handles Tab key by autocompleting command in the current box if it's a new command,
     * or cycles through autocomplete suggestions if nothing else has changed except the TAB press
     */
    private EventHandler<KeyEvent> keyListener = new EventHandler<KeyEvent>() {
        @Override
        public void handle(KeyEvent event) {
            if(event.getCode() == KeyCode.UP && event.isControlDown() == false) {
            	String previousCommand = logic.getPreviousCommand();
            	commandTextField.setText(previousCommand);
            	setCaretPositionToEnd();
            	event.consume();
            	
            } else if(event.getCode() == KeyCode.DOWN && event.isControlDown() == false) {
            	String nextCommand = logic.getNextCommand();
            	commandTextField.setText(nextCommand);
            	setCaretPositionToEnd();
            	event.consume();
            	
            } else if(event.getCode() == KeyCode.TAB) {
            	// If we've gotten a totally new value in the text box - set the autocomplete souce
            	if (hasTextChangedForAutocomplete) {
            		logic.setTextToAutocomplete(commandTextField.getText());
            		hasTextChangedForAutocomplete = false;
            	}
            	
            	// Temporarily disable the text changed listener so that we don't update hasTextChangedForAutocomplete
            	removeTextChangedListener();
            	
            	// Get a new autocompleted command and update the commandTextField
            	String autocompletedCommand = logic.getNextAutocompleteSuggestion();
            	commandTextField.setText(autocompletedCommand);
            	setCaretPositionToEnd();
            	
            	// Add the listener back
            	setTextChangedListener();
            	
            	event.consume();
            	
            } else {
            	return;
            }
        }
    };
    
    private void setTextChangedListener() {
		commandTextField.textProperty().addListener(textChangedListener);
	}
    
    private void removeTextChangedListener() {
    	commandTextField.textProperty().removeListener(textChangedListener);
    }
    
    private void requestFocus() {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                commandTextField.requestFocus();
                
            }
        });
    }
    
```
###### /java/w15c2/tusk/ui/CommandBox.java
``` java
    /**
     * Sets the text cursor to the end of the input in the commandbox currently
     */
    private void setCaretPositionToEnd() {
    	commandTextField.positionCaret(Integer.MAX_VALUE);
    }

}
```
###### /java/w15c2/tusk/ui/ResultDisplay.java
``` java
    /**
     * Consume all events except for scrolling and scrollevents from control up/down
     */
    private void setSelectableCharacteristics() {
        resultDisplayArea.addEventFilter(Event.ANY, new EventHandler<Event>() {
            @Override
            public void handle(Event event) {
               EventType<?> type = event.getEventType().getSuperType();
               if (type != ScrollEvent.ANY && type != ScrollToEvent.ANY) {
                   event.consume();
               } 
            }
        });
    }

```
###### /java/w15c2/tusk/ui/MainWindow.java
``` java
    /**
     * Captures control up/down events and scrolls up/down the task list as required
     * @param scene the scene to apply this handler to
     */
    private void setSceneHandlers(Scene scene) {
        scene.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent event) {
				if (controlPlusDown.match(event)) {
					taskListPanel.scrollDown();
				} else if (controlPlusUp.match(event)) {
					taskListPanel.scrollUp();
				}
			}
        	
        });
		
	}
    
```
###### /java/w15c2/tusk/logic/LogicManager.java
``` java
    @Override
    public String getPreviousCommand() {
    	return commandHistory.getPreviousCommand();
    }
    
    @Override
    public String getNextCommand() {
    	return commandHistory.getNextCommand();
    }

	@Override
	public void setTextToAutocomplete(String text) {
		currentAutocompleteResult = autocompleteEngine.getQueryResult(text);		
	}

	@Override
	public String getNextAutocompleteSuggestion() {
		assert currentAutocompleteResult != null;
		
		return currentAutocompleteResult.getNextMatch();
		
	}
}
```
###### /java/w15c2/tusk/logic/parser/SetStorageCommandParser.java
``` java
/**
 * Parses the setstorage command
 */
public class SetStorageCommandParser extends CommandParser{
    public static final String COMMAND_WORD = SetStorageCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = SetStorageCommand.ALTERNATE_COMMAND_WORD;

    @Override
    public TaskCommand prepareCommand(String arguments) {
        return new SetStorageCommand(arguments);
    }

}
```
###### /java/w15c2/tusk/logic/parser/UnpinCommandParser.java
``` java
/**
 * Parses Unpin commands
 */
public class UnpinCommandParser extends CommandParser{
	public static final String COMMAND_WORD = UnpinTaskCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = UnpinTaskCommand.ALTERNATE_COMMAND_WORD;

    private static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

	/**
     * Parses arguments in the context of the Unpin task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	public TaskCommand prepareCommand(String arguments) {
		 Optional<Integer> index = parseIndex(arguments);
	        if(!index.isPresent()){
	            return new IncorrectTaskCommand(
	                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnpinTaskCommand.MESSAGE_USAGE));
	        }

	        return new UnpinTaskCommand(index.get());
	}
	
	/**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     * Returns an {@code Optional.empty()} otherwise.
     * @param commmand arguments to parse
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
}
```
###### /java/w15c2/tusk/logic/parser/PinCommandParser.java
``` java
/**
 * Parses Pin commands
 */
public class PinCommandParser extends CommandParser{
	public static final String COMMAND_WORD = PinTaskCommand.COMMAND_WORD;
    public static final String ALTERNATE_COMMAND_WORD = PinTaskCommand.ALTERNATE_COMMAND_WORD;

    private static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

	/**
     * Parses arguments in the context of the Pin task command.
     * @param args full command args string
     * @return the prepared command
     */ 
	public TaskCommand prepareCommand(String arguments) {
		 Optional<Integer> index = parseIndex(arguments);
	        if(!index.isPresent()){
	            return new IncorrectTaskCommand(
	                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, PinTaskCommand.MESSAGE_USAGE));
	        }

	        return new PinTaskCommand(index.get());
	}
	/**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     * Returns an {@code Optional.empty()} otherwise.
     * @param command command arguments to parse
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));
    }
    
    
}
```
###### /java/w15c2/tusk/logic/autocomplete/AutocompleteResult.java
``` java
/**
 * Cycles through all matches infinitely
 */
public class AutocompleteResult {
	
	private Iterator<String> matchIterator;
	
	public AutocompleteResult(List<String> matchedWords) {
		assert matchedWords != null;
		assert matchedWords.size() > 0;
		
		// Infinite circular iterator for the list of matched words
		this.matchIterator = Iterables.cycle(matchedWords).iterator();
	}
	
	public String getNextMatch() {
		assert matchIterator != null;
		return matchIterator.next();		
	}
	
	
}
```
###### /java/w15c2/tusk/logic/autocomplete/AutocompleteSource.java
``` java
/**
 * Returns a set of words for autocomplete purposes based on the requested
 * source
 */
public class AutocompleteSource {
    
    /**
     * Iterate through all parsers and get the command words, fail with assertion errors on any problems
       because we don't expect any non-programming related issues in this method
     * @return
     */
	public static Set<String> getCommands() {

		
		Class<?>[] parserTypes = CommandParserList.getList();
		Logger logger = LogsCenter.getLogger(AutocompleteSource.class);
		Set<String> commandWords = new HashSet<String>();
		
		for (Class<?> parser : parserTypes) {
			try {
				String commandWord = (String) parser.getField("COMMAND_WORD").get(null);
				String altCommandWord = (String) parser.getField("ALTERNATE_COMMAND_WORD").get(null);
				
				commandWords.add(commandWord);
				if (altCommandWord != null) {
				    commandWords.add(altCommandWord);
				}
				
			} catch (NoSuchFieldException ex) {
				logger.severe("No such field - check parser list, exception: " + ex.getMessage());
				assert false;
			} catch (Exception e) {
				logger.severe("Generic exception: " + e.getMessage());
				assert false;
			}
		}
		
		return commandWords;
	}
}
```
###### /java/w15c2/tusk/logic/autocomplete/AutocompleteEngine.java
``` java
/**
 * Contains a set of words to match autocomplete 
 * When a new query is received, returns an AutocompleteResult object that the consumer
 * can iterate through.
 *
 */
public class AutocompleteEngine {

	private final Set<String> wordsToMatch;
	
	public AutocompleteEngine() {
		this(new HashSet<String>());
	}

	public AutocompleteEngine(Set<String> wordsToMatch) {
		this.wordsToMatch = wordsToMatch;
	}

	/**
	 * Filters the list of autocompletable words and dispatches it to 
     * an AutocompleteResult object, which is responsible for continually passing a
     * string to fulfil autocomplete requests
	 * @param toMatch the string to autocomplete
	 * @return a cyclically iterable list of autocomplete results
	 */
	public AutocompleteResult getQueryResult(String toMatch) {
		assert wordsToMatch != null;
		
		// Checks if any words in the set start with the word we are matching with
		List<String> matchedWords = wordsToMatch.stream().filter(word -> word.startsWith(toMatch)).collect(Collectors.toList());
		
		// If we receive no matches - we need to return the word itself as a match.
		if (matchedWords.isEmpty()) {
			matchedWords.add(toMatch);
		}
		
		return new AutocompleteResult(matchedWords);
	}
}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/UnpinTaskCommand.java
``` java
/**
 * Unpins a task identified using it's last displayed index from TaskManager.
 */
public class UnpinTaskCommand extends TaskCommand {

	public static final String COMMAND_WORD = "unpin";
    public static final String ALTERNATE_COMMAND_WORD = null;
    public static final String COMMAND_FORMAT = COMMAND_WORD + " <INDEX>";
    public static final String COMMAND_DESCRIPTION = "Unpin a Task"; 
	
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unpins the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";
    
    public static final String MESSAGE_UNPIN_TASK_SUCCESS = "Unpinned task: %1$s";
    public static final String MESSAGE_TASK_ALR_UNPINNED = "Task is already an unpinned task";


    public final int targetIndex;

    public UnpinTaskCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    /**
     * Unpin the specified task if it is currently pinned
     */
    public CommandResult execute() {

	    ObservableList<Task> lastShownList = model.getCurrentFilteredTasks();

        if (lastShownList.size() < targetIndex || targetIndex <= 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        Task taskToUnpin = lastShownList.get(targetIndex - 1);
        if(taskToUnpin.isPinned()){
        	model.unpinTask(taskToUnpin);
        	closeHelpWindow();
        	return new CommandResult(String.format(MESSAGE_UNPIN_TASK_SUCCESS, taskToUnpin));
        }
        else{
        	return new CommandResult(MESSAGE_TASK_ALR_UNPINNED);
        }
    }
    
```
###### /java/w15c2/tusk/logic/commands/taskcommands/TaskCommand.java
``` java
/**
 * Represents a Task command with hidden internal logic and the ability to be executed.
 */
public abstract class TaskCommand {
	protected Model model;
	
    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of tasks.
     *
     * @param displaySize used to generate summary
     * @return summary message for tasks displayed
     */
    public static String getMessageForTaskListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_TASKS_LISTED_OVERVIEW, displaySize);
    }
	
    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult execute();

    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     * @param model the current internal state of the task manager for the command to refer to
     */
    public void setData(Model model) {
        this.model = model;
    }
    
    /**
     * Raises an event to close the help window
     */
    protected void closeHelpWindow() {
        EventsCenter.getInstance().post(new HideHelpRequestEvent());
    }

    /**
     * Raises an event to indicate an attempt to execute an incorrect command
     */
    protected void indicateAttemptToExecuteIncorrectCommand() {
        EventsCenter.getInstance().post(new IncorrectTaskCommandAttemptedEvent(this));
    }
}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/AddTaskCommand.java
``` java
    /**
     * Raises an event to scroll to a particular event in the main task list
     * @param index the index in the list to scroll to
     */
    private void raiseScrollTo(int index) {
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
    }

}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/PinTaskCommand.java
``` java
/**
 * Pins a task identified using it's last displayed index from TaskManager.
 */
public class PinTaskCommand extends TaskCommand {

	public static final String COMMAND_WORD = "pin";
    public static final String ALTERNATE_COMMAND_WORD = null;
    public static final String COMMAND_FORMAT = COMMAND_WORD + " <INDEX>";
    public static final String COMMAND_DESCRIPTION = "Pin a Task"; 
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Pins the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_PIN_TASK_SUCCESS = "Pinned task: %1$s";
    public static final String MESSAGE_TASK_ALR_PINNED = "Task has already been pinned";

    public final int targetIndex;

    public PinTaskCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    /**
     * Sets a task as pinned if it is currently not pinned
     */
    public CommandResult execute() {

	    ObservableList<Task> lastShownList = model.getCurrentFilteredTasks();

        if (lastShownList.size() < targetIndex || targetIndex <= 0) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        Task taskToPin = lastShownList.get(targetIndex - 1);

        if(!taskToPin.isPinned()){
            closeHelpWindow();
        	model.pinTask(taskToPin);
            return new CommandResult(String.format(MESSAGE_PIN_TASK_SUCCESS, taskToPin));
        }
        else{
        	return new CommandResult(MESSAGE_TASK_ALR_PINNED);
        }
    }

}
```
###### /java/w15c2/tusk/logic/commands/taskcommands/SetStorageCommand.java
``` java
/**
 * Sets the application storage location to another folder
 */
public class SetStorageCommand extends TaskCommand {

	public static final String COMMAND_WORD = "setstorage";
    public static final String ALTERNATE_COMMAND_WORD = null;
    
    public static final String COMMAND_FORMAT = COMMAND_WORD + " <FOLDERPATH>";
    public static final String COMMAND_DESCRIPTION = "Set Storage Location"; 

	public static final String MESSAGE_USAGE = COMMAND_WORD 
			+ ": Sets the folder to be used for storage\n" 
			+ "Parameters: FOLDERPATH\n"
			+ "Example: " + COMMAND_WORD + " C:/Users/Bob/Desktop/";

	public static final String MESSAGE_SET_STORAGE_SUCCESS = "Storage location succesfully set to %1$s.";
	public static final String MESSAGE_SET_STORAGE_FAILURE_PATH_INVALID = "Cannot set storage location to \"%1$s\", path is invalid!";
	public static final String MESSAGE_SET_STORAGE_FAILURE_NOT_DIRECTORY = "Cannot set storage location to \"%1$s\", this is not a directory!";
	public static final String MESSAGE_SET_STORAGE_FAILURE_CANNOT_READ = "Cannot set storage location to \"%1$s\", cannot read from here!";	
	public static final String MESSAGE_SET_STORAGE_FAILURE_CANNOT_WRITE = "Cannot set storage location to \"%1$s\", cannot write to here!";
	
	String storageLocation;

	public SetStorageCommand(String storageLocation) {
		this.storageLocation = storageLocation;
	}

	@Override
	/*
	 * Checks if the path that the user provided is a directory, readble and writable, and if so,
	 * requests to change the current storage location to the given path through an event.
	 * (non-Javadoc)
	 * @see w15c2.tusk.logic.commands.taskcommands.TaskCommand#execute()
	 */
	public CommandResult execute() {
		Optional<Path> path = getValidPath(storageLocation);
		if (!path.isPresent()) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(String.format(MESSAGE_SET_STORAGE_FAILURE_PATH_INVALID, storageLocation));
		} else {
			Path actualPath = path.get();
			if (!isDirectory(actualPath)) {
				return new CommandResult(String.format(MESSAGE_SET_STORAGE_FAILURE_NOT_DIRECTORY, actualPath.toAbsolutePath()));
			} else if (!isReadable(actualPath)) {
				return new CommandResult(String.format(MESSAGE_SET_STORAGE_FAILURE_CANNOT_READ, actualPath.toAbsolutePath()));
			} else if (!isWritable(actualPath)) {
				return new CommandResult(String.format(MESSAGE_SET_STORAGE_FAILURE_CANNOT_WRITE, actualPath.toAbsolutePath()));
			}
		}
		Path actualPath = path.get();
		EventsCenter.getInstance().post(new StorageChangedEvent(storageLocation));
		closeHelpWindow();
		return new CommandResult(String.format(MESSAGE_SET_STORAGE_SUCCESS, actualPath.toAbsolutePath()));
	}
	
	/*
	 * Checks if a provided folder path from the user is a valid path
	 */
	private Optional<Path> getValidPath(String folderpath) {
		if (folderpath == null || folderpath.isEmpty()) {
			return Optional.empty();
		}
		
		try {
			Path path = Paths.get(folderpath);
			return Optional.of(path);
			//return Files.isDirectory(path) && Files.isWritable(path) && Files.isReadable(path);
		} catch (InvalidPathException ipe) {
			return Optional.empty();
		} catch (SecurityException sece) {
			return Optional.empty();
		}
		
	}
	
	private boolean isDirectory(Path path) {
		return Files.isDirectory(path);
	}
	
	private boolean isWritable(Path path) {
		return Files.isWritable(path);
	}
	
	private boolean isReadable(Path path) {
		return Files.isReadable(path);
	}
	

}
```
###### /java/w15c2/tusk/logic/commands/CommandHistory.java
``` java
/**
 * Stores all previously entered commands (in textual form) and allows for specific access to previous/next commands
 */
public class CommandHistory {

	// Stores all the previous commands
	private List<String> commandHistoryList = new ArrayList<String>();
	
	// Index into the list to return previous/next commands
	private int listPointer = -1;
	
	/**
	 * Adds a new command to the historical list of commands
	 * @param commandText the text of the command to be added
	 */
	public void addCommandTextToHistory(String commandText) {
		assert commandHistoryList != null;
		assert commandText != null;
		
		commandHistoryList.add(commandText);
		
		// Reset the pointer to just after the latest element
		listPointer = commandHistoryList.size();
	}
	
	public String getPreviousCommand() {
		// Go back by one command
		listPointer--;
		
		return getCommandByListPointer();
	}
	
	public String getNextCommand() {
		// Go forward by one command
		listPointer++;
		
		return getCommandByListPointer();
	}
	
	/**
	 * Gets a command from the command history based on the current list pointer
	 * @return a command from the command history
	 */
	private String getCommandByListPointer() {
		assert commandHistoryList != null;
		// Ensure that the list pointer isn't outside the bounds of the list 
		boundListPointer();
		
		// Handle edge case of no elements in list
		if (commandHistoryList.isEmpty()) {
			// Return a blank command
			return "";
		} else {
			return commandHistoryList.get(listPointer);
		}
	}

	/**
	 * Forces the list pointer to stay within the bounds of the list
	 */
	private void boundListPointer() {
		if (listPointer < 0) {
			listPointer = 0;
		} else if (listPointer >= commandHistoryList.size()) {
			listPointer = commandHistoryList.size() - 1;
		}
	}
	
	
}
```
###### /java/w15c2/tusk/logic/Logic.java
``` java
    /** Returns the previous command in the command history */
    String getPreviousCommand();
    
    /** Returns the next command in the command history */
    String getNextCommand();
    
    /** Sets the text that should be used as the source for autocomplete suggestions */
    void setTextToAutocomplete(String text);
    
    /** Uses the text set as the autcomplete source to return another autocomplete suggestion  */
    String getNextAutocompleteSuggestion();

}
```
###### /java/w15c2/tusk/MainApp.java
``` java
    /**
     * Handles the event when a command indicates that the storage location should
     * be changed
     */
    @Subscribe
    private void handleStorageChangedEvent(StorageChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        
        // Set the new storage location in the config object
        config.setStorageLocation(event.getStoragePath());
        
        try {
        	// Save the config object so that the changed file location is updated on next app reload
        	TaskConfigUtil.saveConfig(config, TaskConfig.DEFAULT_CONFIG_FILE);
        	UniqueItemCollection<Task> tasks = storage.readTaskManager().orElse(new UniqueItemCollection<Task>());
        	UniqueItemCollection<Alias> aliases = storage.readAlias().orElse(new UniqueItemCollection<Alias>());
        	
        	// Reinitialize the current storage object
        	storage = new StorageManager(config.getTasksFilePath(), config.getAliasFilePath(), config.getUserPrefsFilePath());
        	
        	// Save the current status of everything into the new location
        	// This is if we close the app without adding new tasks
        	storage.saveTaskManager(tasks);
        	storage.saveAlias(aliases);
        
        } catch (IOException iox) {
        	EventsCenter.getInstance().post(new DataSavingExceptionEvent(iox));
        } catch (DataConversionException dcex) {
        	EventsCenter.getInstance().post(new DataSavingExceptionEvent(dcex));
        }
    }


    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /java/w15c2/tusk/storage/task/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String description;
    
    @XmlElement(required = true)
    private boolean pin;
    
    @XmlElement(required = true)
    private boolean complete;
    
    @XmlElement(required = true)
    private Date startDate;
    
    @XmlElement(required = true)
    private Date endDate;
    
    @XmlElement(required = true)
    private Class<?> taskType;
    
    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}

    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(Task source) {
    	description = source.getDescription().toString();
    	pin = source.isPinned();
    	complete = source.isCompleted();
    	taskType = source.getClass();
    	
    	// Set dates appropriately
    	if (source instanceof DeadlineTask) {
    		startDate = null;
    		endDate = ((DeadlineTask)source).getDeadline();
    	} else if (source instanceof EventTask) {
    		EventTask castedSource = (EventTask)source;
    		startDate = castedSource.getStartDate();
    		endDate = castedSource.getEndDate();    		
    	} else {
    		startDate = null;
    		endDate = null;
    	}
    	
    	
    }

    /**
     * Converts this jaxb-friendly adapted task object into an appropriate Task subclass..
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
    	if (taskType == Task.class || taskType == null) {
    		throw new IllegalValueException("Incorrect task type: " + taskType.toString());
    	}
    	
    	Task taskToReturn = null;
    	
    	// Set dates
    	if (taskType == FloatingTask.class) {
    		taskToReturn =  new FloatingTask(description);
    	} else if (taskType == DeadlineTask.class) {
    		taskToReturn =  new DeadlineTask(description, endDate);
    	} else if (taskType == EventTask.class) {
    		taskToReturn =  new EventTask(description, startDate, endDate);
    	} else {
    		throw new IllegalValueException("Incorrect task type: " + taskType.toString());
    	}
    	
    	// Set pin
    	if (pin) {
    		taskToReturn.setAsPin();
    	} else {
    		taskToReturn.setAsNotPin();
    	}
    	
    	//Set complete
    	if (complete) {
    		taskToReturn.setAsComplete();
    	}
    	
    	return taskToReturn;
        
    }
    
```
###### /java/w15c2/tusk/model/ModelManager.java
``` java
	@Override
	public void refreshTasksFilter() {
		Predicate<? super Task> currentPredicate = filteredTasks.getPredicate();
		filteredTasks.setPredicate(null);
		filteredTasks.setPredicate(currentPredicate);
	}
	
	@Override
	public void filterCompletedTasks(){
	    EventsCenter.getInstance().post(new FilterLabelChangeEvent(COMMANDTYPE.ListComplete));
		filteredTasks.setPredicate(p -> p.isCompleted());
	}

	@Override
	public UnmodifiableObservableList<Task> getCurrentFilteredTasks() {
		return new UnmodifiableObservableList<>(filteredTasks);
	}
    
    @Override
	public UnmodifiableObservableList<Alias> getAlias() {
		return new UnmodifiableObservableList<>(aliases.getInternalList());
	}
    
   
```
###### /java/w15c2/tusk/model/task/Task.java
``` java
	/*
	 * All tasks are required to minimally have a description
	 */
	protected Description description;
		
	/*
	 * Indicates if this task is pinned
	 */
	protected boolean pin = false;
	
```
###### /java/w15c2/tusk/model/task/Task.java
``` java
	@Override
	public void setAsPin() {
		this.pin = true;
	}
	
	@Override
	public void setAsNotPin() {
		this.pin = false;
	}
	
	@Override
	public boolean isPinned() {
		return this.pin;
	}
	
```
###### /java/w15c2/tusk/model/task/Task.java
``` java
	public Task() {
		this(new Description());
	}
	
	public Task(Description description) {
		this.description = description;
	}

	public Description getDescription() {
		return description;
	}	
	
	public boolean isOverdue() {
	    return false;
	}
	
	@Override
	public String toString() {
		return description.toString();
	}
	
	// Return the specifics of the task (with or without details of time)
	public abstract String getTaskDetails(boolean withTime);
	
	/**
	 * Checks for equality between possible subclasses of Task.
	 * (non-Javadoc)
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object other) {
	    
	    // Cannot be equal to null
	    if (other == null) {
	        return false;
	    }
	    
	    // For now: this is very subclass dependant - assert these conditions
        assert (this instanceof FloatingTask) || (this instanceof DeadlineTask) || (this instanceof EventTask);
        
        
	    boolean isDifferentType = !(other instanceof Task);
	    boolean isDifferentSubclassType = this.getClass() != other.getClass();
	    if (isDifferentType || isDifferentSubclassType) {
	        return false;
	    }
	    
	    // Both are tasks of the same subclass type
	    Task otherTask = (Task)other;
	    
        // Checks basic info for equality
        boolean areEqual = (this.isPinned() == otherTask.isPinned()) && (this.isCompleted() == otherTask.isCompleted())
                && (this.getDescription().equals(otherTask.getDescription()));
        
        // Check for date equality
        if (this instanceof DeadlineTask) {
            areEqual &= ((DeadlineTask)this).getDeadline().equals(((DeadlineTask)otherTask).getDeadline());
        } else if (this instanceof EventTask) {
            areEqual &= ((EventTask)this).getStartDate().equals(((EventTask)otherTask).getStartDate());
            areEqual &= ((EventTask)this).getEndDate().equals(((EventTask)otherTask).getEndDate());
        }
        
        return areEqual;

	}
	
    /**
     * Defines an ordering of tasks in a list.
     * Ordering: 1. Pinned 2. Overdue 3. Floating 4. Date order
     * (non-Javadoc)
     * @see java.lang.Comparable#compareTo(java.lang.Object)
     */
	@Override
	public int compareTo(Task other) {
	    
	    // For now: this is very subclass dependant - assert these conditions
	    assert (this instanceof FloatingTask) || (this instanceof DeadlineTask) || (this instanceof EventTask);
	    
	    // Pinned tasks are the highest priority
		if (this.isPinned() && !other.isPinned()) {
			return -1;
		} else if (!this.isPinned() && other.isPinned()) {
			return 1;
		} 

		// Compare overdue-ness between tasks
        if (this.isOverdue() && !other.isOverdue()) {
            return -1;
        } else if (!this.isOverdue() && other.isOverdue()) {
            return 1;
        }
	      
	    // Floating tasks should come first
        if (this instanceof FloatingTask && !(other instanceof FloatingTask)) {
            return -1;
        } else if (!(this instanceof FloatingTask) && other instanceof FloatingTask) {
            return 1;
        } else if (this instanceof FloatingTask && other instanceof FloatingTask) {
            // If both are floating tasks - they are equal
            return 0;
        }
        
        // Depending on the class type - get the date that we want to compare
        Date myDateToCompare = this instanceof DeadlineTask ? ((DeadlineTask)this).getDeadline() : ((EventTask)this).getStartDate();
        Date otherDateToCompare = other instanceof DeadlineTask ? ((DeadlineTask)other).getDeadline() : ((EventTask)other).getStartDate();
        
        // Sort based on date
        return myDateToCompare.compareTo(otherDateToCompare);
	}
	
}
```
###### /java/w15c2/tusk/model/task/PinnableTask.java
``` java
/*
 * Tasks that implement this interface can be pinned
 */
public interface PinnableTask {
	
	/*
	 * Gives the task a 'pin' status
	 */
	public void setAsPin();
	
	/*
	 * Removes the task's 'pin' status
	 */
	public void setAsNotPin();
	
	/*
	 * Checks if a task is pinned
	 */
	public boolean isPinned();
}
```
###### /java/w15c2/tusk/model/task/Description.java
``` java
/**
 * Represents an immutable description for a Task.
 */
public class Description {
	private final String content;
	
	public Description() {
		this.content = "";
	}
	
	public Description(String content) {
		this.content = content;
	}

	public String getContent() {
		return content;
	}
	
	@Override
	public boolean equals(Object other) {
	    return this.toString().equals(other.toString());
	}
	
	@Override
	public String toString() {
		return getContent();
	}
}
```
