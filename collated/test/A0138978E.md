# A0138978E
###### /java/guitests/AddCommandTest.java
``` java
public class AddCommandTest extends TaskManagerGuiTest {

    @Test
    public void add() {
        //add one task
        List<Task> currentTaskList = TestUtil.getInitialTasks().getInternalList();
        List<Task> tasksToAdd = TestUtil.getDefaultTasks().getInternalList();
        Task taskToAdd = tasksToAdd.get(0);
        
        assertAddSuccess(taskToAdd, currentTaskList);

        //add another task
        taskToAdd = tasksToAdd.get(1);
        assertAddSuccess(taskToAdd, currentTaskList);

        //add duplicate task but should pass
        taskToAdd = taskToAdd.copy();
        assertAddSuccess(taskToAdd, currentTaskList);

        //add to empty list
        taskToAdd = tasksToAdd.get(2);
        commandBox.runCommand("clear");
        currentTaskList.clear();
        assertAddSuccess(taskToAdd, currentTaskList);

        //invalid command (no description)
        commandBox.runCommand("add");
        assertResultMessage(AddTaskCommand.MESSAGE_EMPTY_TASK + AddTaskCommand.MESSAGE_USAGE);
    }

    private void assertAddSuccess(Task taskToAdd, List<Task> currentTaskList) {
        commandBox.runCommand(TaskTesterUtil.getAddCommandFromTask(taskToAdd));

        //confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(taskToAdd);
        assertMatching(taskToAdd, addedCard);

        //confirm the list now contains all previous persons plus the new person
        currentTaskList.add(taskToAdd);
        assertTrue(taskListPanel.isListMatching(currentTaskList));
    }

}
```
###### /java/guitests/AliasCommandTest.java
``` java
public class AliasCommandTest extends TaskManagerGuiTest {

    @Test
    public void openAliasWindow() {
        commandBox.runCommand("list alias");
        assertAliasWindowOpen(mainGui.getAliasWindow());
    }
    
    @Test
    public void addOneAlias() {
        Alias aliasToAdd = new Alias("am", "add meeting");
        commandBox.runCommand(AliasTesterUtil.getAddAliasCommandFromAlias(aliasToAdd));
        commandBox.runCommand("list alias");
        
        assertAddAliasSuccess(mainGui.getAliasWindow(), new ArrayList<Alias>(), aliasToAdd);
    }

    private void assertAddAliasSuccess(AliasWindowHandle aliasWindowHandle, List<Alias> currentAliasList, Alias addedAlias) {
        assertTrue(aliasWindowHandle.isWindowOpen());
        AliasCardHandle addedAliasCard = aliasWindowHandle.getAliasCardHandle(addedAlias);
        assertTrue(addedAliasCard.isSameAlias(addedAlias));
        aliasWindowHandle.closeWindow();
    }
    
    private void assertAliasWindowOpen(AliasWindowHandle aliasWindowHandle) {
        assertTrue(aliasWindowHandle.isWindowOpen());
        aliasWindowHandle.closeWindow();
    }
}
```
###### /java/guitests/ClearCommandTest.java
``` java
public class ClearCommandTest extends TaskManagerGuiTest {

    @Test
    public void clear() {

        List<Task> initialTasks = TestUtil.getInitialTasks().getInternalList();
        int initialListSize = initialTasks.size();
        
        //verify a non-empty list can be cleared
        assertTrue(taskListPanel.isListMatching(TestUtil.getInitialTasks().getInternalList()));
        assertClearCommandSuccess(initialListSize);

        //verify other commands can work after a clear command
        commandBox.runCommand(TaskTesterUtil.getAddCommandFromTask(testTasks.get(0)));
        assertTrue(taskListPanel.isListMatching(testTasks.subList(0, 1)));
        commandBox.runCommand("delete 1");
        assertListSize(0);

        //verify clear command works when the list is empty
        assertClearCommandSuccess(0);
    }

    private void assertClearCommandSuccess(int numberOfTasksCleared) {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage(numberOfTasksCleared + " tasks deleted!");
    }
}
```
###### /java/guitests/CommandBoxTest.java
``` java
public class CommandBoxTest extends TaskManagerGuiTest {

    @Test
    public void commandBox_commandFails_blankAdd() {
        commandBox.runCommand("invalid");
        assertEquals(commandBox.getCommandInput(), "invalid");
    }



}
```
###### /java/guitests/DeleteCommandTest.java
``` java
public class DeleteCommandTest extends TaskManagerGuiTest {

    @Test
    public void delete() {

        //add one task
        List<Task> currentTaskList = TestUtil.getInitialTasks().getInternalList();
        int targetIndex = 1;
        assertDeleteSuccess(targetIndex, currentTaskList);

        //delete the last in the list
        targetIndex = currentTaskList.size();
        assertDeleteSuccess(targetIndex, currentTaskList);

        //delete from the middle of the list
        targetIndex = currentTaskList.size()/2;
        assertDeleteSuccess(targetIndex, currentTaskList);

        //invalid index
        commandBox.runCommand("delete " + currentTaskList.size() + 1);
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

    }

    /**
     * Runs the delete command to delete the task at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. to delete the first task in the list, 1 should be given as the target index.
     * @param currentTaskList The current list of tasks
     */
    private void assertDeleteSuccess(int targetIndexOneIndexed, List<Task> currentTaskList) {
        Task taskToDelete = currentTaskList.get(targetIndexOneIndexed-1); //-1 because array uses zero indexing
        currentTaskList.remove(taskToDelete);
        
        commandBox.runCommand("delete " + targetIndexOneIndexed);

        //confirm the list now contains all previous persons except the deleted person
        assertTrue(taskListPanel.isListMatching(currentTaskList));

        //confirm the result message is correct
        assertResultMessage(String.format(DeleteTaskCommand.MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### /java/guitests/FindCommandTest.java
``` java
public class FindCommandTest extends TaskManagerGuiTest {

    @Test
    public void find_nonEmptyList() {
        List<Task> emptyResults = new ArrayList<>();
        List<Task> currentTaskList = TestUtil.getInitialTasks().getInternalList();
        
        List<Task> results = new ArrayList<>();
        results.add(currentTaskList.get(9));
        results.add(currentTaskList.get(10));
        
        assertFindResult("find totallynonexistenttask", emptyResults); //no results
        assertFindResult("find 10 11", results); //multiple results

        //find after deleting one result
        commandBox.runCommand("delete 2");
        results.remove(1);
        assertFindResult("find 10 11", results);
    }

    @Test
    public void find_emptyList(){
        List<Task> emptyResults = new ArrayList<>();
        commandBox.runCommand("clear");
        assertFindResult("find Jean", emptyResults); //no results
    }

    @Test
    public void find_invalidCommand_fail() {
        commandBox.runCommand("findgeorge");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertFindResult(String command, List<Task> expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.size());
        assertResultMessage(expectedHits.size() + " tasks listed!");
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }
}
```
###### /java/guitests/guihandles/AliasCardHandle.java
``` java
/**
 * Provides a handle to a particular alias card
 */
public class AliasCardHandle extends GuiHandle {
    private static final String ALIAS_SHORTCUT_FIELD_ID = "#cardAlias";
    private static final String ALIAS_COMMAND_FIELD_ID = "#command";
    
    private Node node;

    public AliasCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node){
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getShortcut() {
        return getTextFromLabel(ALIAS_SHORTCUT_FIELD_ID);
    }
    
    public String getSentence() {
        return getTextFromLabel(ALIAS_COMMAND_FIELD_ID);
    }

    public boolean isSameAlias(Alias alias){
        return getShortcut().equals(alias.getShortcut()) && getSentence().equals(alias.getSentence());
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof AliasCardHandle) {
            AliasCardHandle handle = (AliasCardHandle) obj;
            return getShortcut().equals(handle.getShortcut());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getShortcut();
    }
}
```
###### /java/guitests/guihandles/AliasWindowHandle.java
``` java
/**
 * Provides a handle to the alias window of the app.
 */
public class AliasWindowHandle extends GuiHandle {

    private static final String ALIAS_WINDOW_TITLE = "Alias List";
    private static final String ALIAS_LIST_VIEW_ID = "#aliasListView";
    private static final String ALIAS_CARD_PANE_ID = "#cardPane";

    public AliasWindowHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, ALIAS_WINDOW_TITLE);
        guiRobot.sleep(1000);
    }
    
    public ListView<Alias> getListView() {
        return (ListView<Alias>) getNode(ALIAS_LIST_VIEW_ID);
    }
    
    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(ALIAS_CARD_PANE_ID).queryAll();
    }

    
    public AliasCardHandle getAliasCardHandle(Alias alias) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> aliasCardNode = nodes.stream()
                .filter(n -> new AliasCardHandle(guiRobot, primaryStage, n).isSameAlias(alias))
                .findFirst();
        if (aliasCardNode.isPresent()) {
            return new AliasCardHandle(guiRobot, primaryStage, aliasCardNode.get());
        } else {
            return null;
        }
    }
    
    public AliasCardHandle getTaskCardHandle(int index) {
        return getAliasCardHandle(getListView().getItems().get(index));
    }

    public boolean isWindowOpen() {
        return getNode(ALIAS_LIST_VIEW_ID) != null;
    }

    public void closeWindow() {
        super.closeWindow();
        guiRobot.sleep(500);
    }

}
```
###### /java/guitests/guihandles/CommandBoxHandle.java
``` java
/**
 * A handle to the Command Box in the GUI.
 */
public class CommandBoxHandle extends GuiHandle{

    private static final String COMMAND_INPUT_FIELD_ID = "#commandTextField";

    public CommandBoxHandle(GuiRobot guiRobot, Stage primaryStage, String stageTitle) {
        super(guiRobot, primaryStage, stageTitle);
    }

    public void enterCommand(String command) {
        setTextField(COMMAND_INPUT_FIELD_ID, command);
    }

    public String getCommandInput() {
        return getTextFieldText(COMMAND_INPUT_FIELD_ID);
    }

    /**
     * Enters the given command in the Command Box and presses enter.
     */
    public void runCommand(String command) {
        enterCommand(command);
        pressEnter();
        guiRobot.sleep(200); //Give time for the command to take effect
    }

}
```
###### /java/guitests/guihandles/TaskCardHandle.java
``` java
/**
 * Provides a handle to a person card in the person list panel.
 */
public class TaskCardHandle extends GuiHandle {
    private static final String DESCRIPTION_FIELD_ID = "#description";

    private Node node;

    public TaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node){
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getDescription() {
        return getTextFromLabel(DESCRIPTION_FIELD_ID);
    }

    public boolean isSameTask(Task task){
        return getDescription().equals(task.getDescription().toString());
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof TaskCardHandle) {
            TaskCardHandle handle = (TaskCardHandle) obj;
            return getDescription().equals(handle.getDescription());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getDescription();
    }
}
```
###### /java/w15c2/tusk/commons/core/TaskConfigTest.java
``` java
    @Test
    public void toString_defaultObject_stringReturned() {
        String defaultConfigAsString = "App title : Tusk\n" +
                "Current log level : INFO\n" +
                "Preference file Location : task-userpreferences.json\n" +
                "Local data file location : data/tasks.xml\n" +
                "Local alias file location : " + "data/alias.xml\n" +
                "AddressBook name : Tusk";

        assertEquals(defaultConfigAsString, new TaskConfig().toString());
    }

    @Test
    public void equalsMethod(){
        TaskConfig defaultConfig = new TaskConfig();
        assertFalse(defaultConfig.equals(null));
        assertTrue(defaultConfig.equals(defaultConfig));
    }
    
    @Test
    public void setStorageLocationMethod() {
    	TaskConfig config = new TaskConfig();
    	String validPath = System.getProperty("user.home");
    	config.setStorageLocation(validPath);
    	
    	assertEquals(config.getTasksFilePath(), Paths.get(validPath, "tasks.xml").toString());
    	assertEquals(config.getAliasFilePath(), Paths.get(validPath, "alias.xml").toString());
    }


}
```
###### /java/w15c2/tusk/commons/util/StringUtilTest.java
``` java
    @Test
    public void addSpacesBetweenNumbersAndWords_combinedNumberWordStringsGiven() {
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("31Oct2016"), "31 Oct 2016");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct312016"), "Oct 312016");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct201631"), "Oct 201631");
    }
    
    @Test
    public void addSpacesBetweenNumbersAndWords_withStNdRdTh() {
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("1st"), "1st");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("2nd"), "2nd");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("3rd"), "3rd");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("4th"), "4th");
    	
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("1st31Oct2016"), "1st 31 Oct 2016");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("2ndOct312016"), "2ndOct 312016");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("3rdOct201631"), "3rdOct 201631");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("4thOct201631"), "4thOct 201631");
    	
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("31Oct20161st"), "31 Oct 20161st");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct3120162nd"), "Oct 3120162nd");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct2016313rd"), "Oct 2016313rd");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct2016314th"), "Oct 2016314th");
    }
    
    
    @Test
    public void addSpacesBetweenNumbersAndWords_separatedNumberWordStringsGiven() {
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("31 Oct 2016"), "31 Oct 2016");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct 31 2016"), "Oct 31 2016");
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords("Oct 2016 31"), "Oct 2016 31");
    }
    
    @Test
    public void addSpacesBetweenNumbersAndWords_nullGiven() {
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords(null), null);
    }
    
    @Test
    public void addSpacesBetweenNumbersAndWords_emptyGiven() {
    	assertEquals(StringUtil.addSpacesBetweenNumbersAndWords(""), "");
    }


}
```
###### /java/w15c2/tusk/logic/autocomplete/AutocompleteEngineTest.java
``` java
public class AutocompleteEngineTest {
	private AutocompleteEngine autocompleteEngine;
	
	@Test
	public void autocompleteEngine_noWordsToMatch() {
		autocompleteEngine = new AutocompleteEngine();
		AutocompleteResult result = autocompleteEngine.getQueryResult("ad");
		assertEquals(result.getNextMatch(), "ad");
		assertEquals(result.getNextMatch(), "ad");
	}
	
	@Test
	public void autocompleteEngine_noWordsCorrectlyMatch() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("delete");
		
		autocompleteEngine = new AutocompleteEngine();
		AutocompleteResult result = autocompleteEngine.getQueryResult("ad");
		assertEquals(result.getNextMatch(), "ad");
		assertEquals(result.getNextMatch(), "ad");
	}
	
	@Test
	public void autocompleteEngine_oneWordMatches() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("add");
		
		autocompleteEngine = new AutocompleteEngine(new HashSet<String>(wordsToMatch));
		AutocompleteResult result = autocompleteEngine.getQueryResult("ad");
		assertEquals(result.getNextMatch(), "add");
		assertEquals(result.getNextMatch(), "add");
	}
	
	@Test
	public void autocompleteEngine_twoWordsMatch() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("add");
		wordsToMatch.add("alias");
		
		autocompleteEngine = new AutocompleteEngine(new HashSet<String>(wordsToMatch));
		AutocompleteResult result = autocompleteEngine.getQueryResult("a");
		assertEquals(result.getNextMatch(), "add");
		assertEquals(result.getNextMatch(), "alias");
		assertEquals(result.getNextMatch(), "add");
	}
	
	@Test
	public void autocompleteEngine_twoWordsMatchOneWordDoesNot() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("delete");
		wordsToMatch.add("add");
		wordsToMatch.add("alias");
		
		autocompleteEngine = new AutocompleteEngine(new HashSet<String>(wordsToMatch));
		AutocompleteResult result = autocompleteEngine.getQueryResult("a");
		assertEquals(result.getNextMatch(), "add");
		assertEquals(result.getNextMatch(), "alias");
		assertEquals(result.getNextMatch(), "add");
	}
	
	@Test
	public void autocompleteEngine_oneWordMatchesTwoWordsDoNot() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("delete");
		wordsToMatch.add("add");
		wordsToMatch.add("alias");
		
		autocompleteEngine = new AutocompleteEngine(new HashSet<String>(wordsToMatch));
		AutocompleteResult result = autocompleteEngine.getQueryResult("d");
		assertEquals(result.getNextMatch(), "delete");
		assertEquals(result.getNextMatch(), "delete");
	}
	
	@Test
	public void autocompleteEngine_twoDifferentQueries() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("delete");
		wordsToMatch.add("add");
		wordsToMatch.add("alias");
		
		autocompleteEngine = new AutocompleteEngine(new HashSet<String>(wordsToMatch));
		AutocompleteResult result = autocompleteEngine.getQueryResult("d");
		assertEquals(result.getNextMatch(), "delete");
		assertEquals(result.getNextMatch(), "delete");
		
		result = autocompleteEngine.getQueryResult("a");
		assertEquals(result.getNextMatch(), "add");
		assertEquals(result.getNextMatch(), "alias");
		assertEquals(result.getNextMatch(), "add");
		
	}

	
}
```
###### /java/w15c2/tusk/logic/autocomplete/AutocompleteResultTest.java
``` java
public class AutocompleteResultTest {
	private AutocompleteResult autocompleteResult;

	@Test(expected = AssertionError.class)
	public void getNextMatch_nullWords() {
		autocompleteResult = new AutocompleteResult(null);
	}

	@Test(expected = AssertionError.class)
	public void getNextMatch_emptyWords() {
		autocompleteResult = new AutocompleteResult(new ArrayList<String>());
	}

	@Test
	public void getNextMatch_oneWord() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("add");

		autocompleteResult = new AutocompleteResult(wordsToMatch);

		for (int i = 0; i < 10; i++) {
			assertEquals(autocompleteResult.getNextMatch(), "add");
		}
	}

	@Test
	public void getNextMatch_twoWords() {
		List<String> wordsToMatch = new ArrayList<String>();
		wordsToMatch.add("add");
		wordsToMatch.add("delete");

		autocompleteResult = new AutocompleteResult(wordsToMatch);

		for (int i = 0; i < 10; i++) {
			assertEquals(autocompleteResult.getNextMatch(), "add");
			assertEquals(autocompleteResult.getNextMatch(), "delete");
		}
	}

}
```
###### /java/w15c2/tusk/logic/autocomplete/AutocompleteSourceTest.java
``` java
public class AutocompleteSourceTest {
	
	@Test
	public void getCommands() throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
		Set<String> expectedCommands = new HashSet<String>();
		Class<?>[] parserList = CommandParserList.getList();
		
		for (Class<?> parser : parserList) {
			String command = (String) parser.getField("COMMAND_WORD").get(null);
			String altCommandWord = (String) parser.getField("ALTERNATE_COMMAND_WORD").get(null);
			
			expectedCommands.add(command);
            if (altCommandWord != null) {
                expectedCommands.add(altCommandWord);
            }
		}
		
		assertEquals(expectedCommands, AutocompleteSource.getCommands());
		
	}
}
```
###### /java/w15c2/tusk/logic/CommandHistoryTest.java
``` java
public class CommandHistoryTest {
	
	private CommandHistory commandHistory;
	
	@Before
	public void setup() {
		commandHistory = new CommandHistory();
	}
	
	@Test
	public void getPreviousHistoryOnce_noHistory_returnEmptyString() {
		assertEquals("", commandHistory.getPreviousCommand());
	}
	
	@Test
	public void getPreviousHistoryOnce_oneCommandInHistory_returnCommand() {
		String commandText = "add meeting";
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getPreviousCommand());
	}
	
	
	@Test
	public void getPreviousHistoryTwice_oneCommandInHistory_returnCommand() {
		String commandText = "add meeting";
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getPreviousCommand());
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getPreviousCommand());
	}
	
	@Test
	public void getPreviousHistoryOnce_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getPreviousCommand());
	}
	
	@Test
	public void getPreviousHistoryTwice_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getPreviousCommand());
		assertEquals(commandText1, commandHistory.getPreviousCommand());
	}
	
	@Test
	public void getNextHistoryOnce_noHistory_returnEmptyString() {
		assertEquals(commandHistory.getNextCommand(), "");
	}
	
	@Test
	public void getNextHistoryOnce_oneCommandInHistory_returnCommand() {
		String commandText = "add meeting";
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getNextCommand());
	}
	
	
	@Test
	public void getNextHistoryTwice_oneCommandInHistory_returnCommand() {
		String commandText = "add meeting";
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getNextCommand());
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getNextCommand());
	}
	
	
	@Test
	public void getNextHistoryOnce_twoCommandsInHistory_returnCommand() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getNextCommand());
	}
	
	@Test
	public void getNextHistoryTwice_twoCommandsInHistory_returnCommand() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getNextCommand());
		assertEquals(commandText2, commandHistory.getNextCommand());
	}
	
	@Test
	public void getPreviousThenNext_oneCommandInHistory_returnCommand() {
		String commandText = "add meeting";
		
		commandHistory.addCommandTextToHistory(commandText);
		assertEquals(commandText, commandHistory.getPreviousCommand());
		assertEquals(commandText, commandHistory.getNextCommand());
	}
	
	@Test
	public void getPreviousThenNext_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getPreviousCommand());
		assertEquals(commandText2, commandHistory.getNextCommand());
	}
	
	@Test
	public void getPreviousThenPreviousThenNext_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getPreviousCommand());
		assertEquals(commandText1, commandHistory.getPreviousCommand());
		assertEquals(commandText2, commandHistory.getNextCommand());
	}
	
	@Test
	public void getPreviousThenPreviousThenPreviousThenNext_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getPreviousCommand());
		assertEquals(commandText1, commandHistory.getPreviousCommand());
		assertEquals(commandText1, commandHistory.getPreviousCommand());
		assertEquals(commandText2, commandHistory.getNextCommand());
	}
	
	@Test
	public void getNextThenPrevious_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getNextCommand());
		assertEquals(commandText1, commandHistory.getPreviousCommand());
	}
	
	@Test
	public void getNextThenPreviousThenNext_twoCommandsInHistory_returnCommands() {
		String commandText1 = "add meeting";
		String commandText2 = "add dinner";
		
		commandHistory.addCommandTextToHistory(commandText1);
		commandHistory.addCommandTextToHistory(commandText2);
		assertEquals(commandText2, commandHistory.getNextCommand());
		assertEquals(commandText1, commandHistory.getPreviousCommand());
		assertEquals(commandText2, commandHistory.getNextCommand());
	}
}
```
###### /java/w15c2/tusk/logic/commands/PinTaskCommandTest.java
``` java
public class PinTaskCommandTest {


	@Test
	public void pinTask_noTasksAdded() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since
		 * there are no tasks that have been added).
		 */
		Model model;
		model = TestUtil.setupEmptyTaskList();
		PinTaskCommand command = new PinTaskCommand(1);
		command.setData(model);
				
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void pinTask_indexTooLarge() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since
		 * index is too large).
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		PinTaskCommand command = new PinTaskCommand(4);
		command.setData(model);
		
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void pinTask_indexTooSmall() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since 
		 * index is too small).
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		PinTaskCommand command = new PinTaskCommand(-1);
		command.setData(model);
		
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void pinTask_duplicatePin() throws IllegalValueException {
		/* 
		 * CommandResult should return a string that denotes success in execution if index given 
		 * to pinTaskCommand constructor is within the range of added tasks.
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		PinTaskCommand command = new PinTaskCommand(2);
		command.setData(model);
		
		String expected = String.format(PinTaskCommand.MESSAGE_PIN_TASK_SUCCESS, "Task 1");
		assertCommandFeedback(command, expected);
	}
	
```
###### /java/w15c2/tusk/logic/commands/PinTaskCommandTest.java
``` java
	/*
	 * Given a command and an expected string, execute the command
	 * and assert that the feedback corresponds to the expected string
	 */
	public void assertCommandFeedback(PinTaskCommand command, String expected) {
		CommandResult result = command.execute();
		String feedback = result.feedbackToUser;
		assertTrue(feedback.equals(expected));
	}
}
```
###### /java/w15c2/tusk/logic/commands/SetStorageCommandTest.java
``` java
public class SetStorageCommandTest {

	@Test
	public void setStorage_nullInput() {
		SetStorageCommand command = new SetStorageCommand(null);
		CommandResult result = command.execute();
		String feedback = result.feedbackToUser;
		assertTrue(feedback.equals(String.format(SetStorageCommand.MESSAGE_SET_STORAGE_FAILURE_PATH_INVALID, null)));
	}
	
	@Test
	public void setStorage_emptyInput() {
		SetStorageCommand command = new SetStorageCommand("");
		CommandResult result = command.execute();
		String feedback = result.feedbackToUser;
		assertTrue(feedback.equals(String.format(SetStorageCommand.MESSAGE_SET_STORAGE_FAILURE_PATH_INVALID, "")));
	}
	
	@Test
	public void setStorage_validLocation() {
		String homeDir = System.getProperty("user.home");
		SetStorageCommand command = new SetStorageCommand(homeDir);
		CommandResult result = command.execute();
		String feedback = result.feedbackToUser;
		assertTrue(feedback.equals(String.format(SetStorageCommand.MESSAGE_SET_STORAGE_SUCCESS, homeDir)));
	}
	

}
```
###### /java/w15c2/tusk/logic/commands/UnpinTaskCommandTest.java
``` java
public class UnpinTaskCommandTest {

	
	@Test
	public void unpinTask_noTasksAdded() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since
		 * there are no tasks that have been added).
		 */
		Model model;
		model = TestUtil.setupEmptyTaskList();
		UnpinTaskCommand command = new UnpinTaskCommand(1);
		command.setData(model);
				
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void unpinTask_indexTooLarge() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since
		 * index is too large).
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		UnpinTaskCommand command = new UnpinTaskCommand(4);
		command.setData(model);
		
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void unpinTask_indexTooSmall() throws IllegalValueException {
		/*
		 * CommandResult should return a string that denotes that execution failed (since 
		 * index is too small).
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		UnpinTaskCommand command = new UnpinTaskCommand(-1);
		command.setData(model);
		
		String expected = Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void unpinTask_validIndex_alreadyUnpin() throws IllegalValueException {
		/* 
		 * CommandResult should return a string that denotes success in execution if index given 
		 * to unpinTaskCommand constructor is within the range of added tasks.
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		UnpinTaskCommand command = new UnpinTaskCommand(2);
		command.setData(model);
		
		String expected = String.format(UnpinTaskCommand.MESSAGE_TASK_ALR_UNPINNED, "[Floating Task][Description: Task 1]");
		assertCommandFeedback(command, expected);
	}
	
	@Test
	public void unpinTask_validIndex_isPin() throws IllegalValueException {
		/* 
		 * CommandResult should return a string that denotes success in execution if index given 
		 * to unpinTaskCommand constructor is within the range of added tasks.
		 */
		Model model;
		model = TestUtil.setupFloatingTasks(3);
		model.getCurrentFilteredTasks().get(1).setAsPin();
		UnpinTaskCommand command = new UnpinTaskCommand(2);
		command.setData(model);
		
		String expected = String.format(UnpinTaskCommand.MESSAGE_UNPIN_TASK_SUCCESS, "Task 1");
		assertCommandFeedback(command, expected);
	}

	/*
	 * Given a command and an expected string, execute the command
	 * and assert that the feedback corresponds to the expected string
	 */
	public void assertCommandFeedback(UnpinTaskCommand command, String expected) {
		CommandResult result = command.execute();
		String feedback = result.feedbackToUser;
		assertTrue(feedback.equals(expected));
	}
}
```
###### /java/w15c2/tusk/model/TaskTest.java
``` java
public class TaskTest {

    @Test
    public void toString_noDescription() {
        Task t1 = new FloatingTask("");
        
        assertEquals(t1.toString(), "");
    }
    
    @Test
    public void toString_hasDescription() {
        Task t1 = new FloatingTask("test");
        
        assertEquals(t1.toString(), "test");
    }
    
    @Test
    public void compareTo_identicalTasks() {
        Task t1 = new FloatingTask("test");
        Task t2 = t1;
        
        assertEquals(t1.compareTo(t2), 0);
    }
    
    @Test
    public void compareTo_differentFloatingTasks() {
        Task t1 = new FloatingTask("test");
        Task t2 = new FloatingTask("test2");
        
        assertEquals(t1.compareTo(t2), 0);
    }
    
    @Test
    public void compareTo_overDueVersusFloating() {
       
        Task t1 = getOverdueTask();
        Task t2 = new FloatingTask("test2");
        
        assertEquals(t1.compareTo(t2), -1);
    }
    
    @Test
    public void compareTo_twoOverdueTasks_oneMoreOverdue() {
       
        Task t1 = getOverdueTask();
        Task t2 = getMoreOverdueTask();
        
        assertEquals(t1.compareTo(t2), 1);
    }
    
    @Test
    public void compareTo_overdueVsPin() {
       
        Task t1 = getOverdueTask();
        Task t2 = t1.copy();
        t2.setAsPin();
        
        assertEquals(t1.compareTo(t2), 1);
    }
    
    @Test
    public void compareTo_floatingVsPin() {
       
        Task t1 = new FloatingTask("test");
        Task t2 = getOverdueTask();
        t2.setAsPin();
        
        assertEquals(t1.compareTo(t2), 1);
    }
    
    @Test
    public void compareTo_twoDeadlineTasks_oneLater() {
       
        Task t1 = getDeadlineTask();
        Task t2 = getLaterDeadlineTask();
        
        assertEquals(t1.compareTo(t2), -1);
    }
    
    @Test
    public void compareTo_twoEventTasks_oneLater() {
       
        Task t1 = getEventTask();
        Task t2 = getLaterEventTask();
        
        assertEquals(t1.compareTo(t2), -1);
    }
    
    @Test
    public void equals_oneTaskoneNull() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = null;
        
        assertNotEquals(t1, t2);
    }
    
    @Test
    public void equals_twoFloatingTasks_sameDescription() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = new FloatingTask("hello world");
        
        assertEquals(t1, t2);
    }
    
    @Test
    public void equals_twoFloatingTasks_differentDescriptions() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = new FloatingTask("hello world 2");
        
        assertNotEquals(t1, t2);
    }
    
    @Test
    public void equals_twoFloatingTasks_differentPinStatus() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = new FloatingTask("hello world");
        t2.setAsPin();
        
        assertNotEquals(t1, t2);
    }
    
    @Test
    public void equals_twoFloatingTasks_differentCompletedStatus() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = new FloatingTask("hello world");
        t2.setAsComplete();
        
        assertNotEquals(t1, t2);
    }
    
    @Test
    public void equals_oneFloatingoneEvent() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = getEventTask();
        
        assertNotEquals(t1, t2);
    }
    
    
    @Test
    public void equals_oneFloatingoneDeadline() {
        Task t1 = new FloatingTask("hello world");
        Task t2 = getDeadlineTask();
        
        assertNotEquals(t1, t2);
    }
    
    
    @Test
    public void equals_twoDeadlineTasks_sameDeadline() {
        Task t1 = getDeadlineTask();
        Task t2 = t1.copy();
        
        assertEquals(t1, t2);
    }
    
    @Test
    public void equals_twoDeadlineTasks_differentDeadlines() {
        Task t1 = getDeadlineTask();
        Task t2 = getLaterDeadlineTask();
        
        assertNotEquals(t1, t2);
    }
    
    @Test
    public void equals_twoEventTasks_sameDates() {
        Task t1 = getEventTask();
        Task t2 = t1.copy();
        
        assertEquals(t1, t2);
    }
    
    @Test
    public void equals_twoEventTasks_differentDates() {
        Task t1 = getEventTask();
        Task t2 = getLaterEventTask();
        
        assertNotEquals(t1, t2);
    }
    
    
    /* Utility functions */
    private Task getOverdueTask() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -1);
        Date yesterday = cal.getTime();
        
        return new DeadlineTask("test", yesterday);
    }
    
    private Task getMoreOverdueTask() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, -2);
        Date dayBeforeYesterday = cal.getTime();
        
        return new DeadlineTask("test", dayBeforeYesterday);
    }
    
    private Task getDeadlineTask() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, 1);
        Date tomorrow = cal.getTime();
        
        return new DeadlineTask("test", tomorrow);
    }
    
    
    private Task getLaterDeadlineTask() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, 2);
        Date dayAfterTomorrow = cal.getTime();
        
        return new DeadlineTask("test", dayAfterTomorrow);
    }
    
    private Task getEventTask() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, 1);
        Date tomorrow = cal.getTime();
        cal.add(Calendar.DATE, 2);
        Date dayAfterTomorrow = cal.getTime();
        
        return new EventTask("test", tomorrow, dayAfterTomorrow);
    }
    
    
    private Task getLaterEventTask() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Date());
        cal.add(Calendar.DATE, 2);
        Date dayAfterTomorrow = cal.getTime();
        cal.add(Calendar.DATE, 3);
        Date threeDaysLater = cal.getTime();
        
        return new EventTask("test", dayAfterTomorrow, threeDaysLater);
    }
    
  
}
```
###### /java/w15c2/tusk/testutil/AliasTesterUtil.java
``` java
/*
 * Utility functions that help with tests that use Aliases
 */
public class AliasTesterUtil {
    public static String getAddAliasCommandFromAlias(Alias alias) {
        StringBuilder command = new StringBuilder("alias " + alias.getShortcut() + " " + alias.getSentence());
        return command.toString();
    }
}
```
###### /java/w15c2/tusk/testutil/TaskTesterUtil.java
``` java
/*
 * Utility functions that help with tests that use Tasks
 */
public class TaskTesterUtil {
    public static String getAddCommandFromTask(Task task) {
        // Add description
        StringBuilder command = new StringBuilder("add " + task.getDescription().toString());
        
        if (task instanceof DeadlineTask) {
            command.append(" by " + ((DeadlineTask)task).getDeadline());
        } else if (task instanceof EventTask) {
            command.append(" from " + ((EventTask)task).getStartDate() + " - " + ((EventTask)task).getEndDate());
        }
        
        return command.toString();
    }
}
```
